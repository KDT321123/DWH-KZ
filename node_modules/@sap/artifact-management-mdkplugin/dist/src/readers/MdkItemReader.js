"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class MdkItemReader {
    constructor() {
        this.E_INVAL_INVO = 'invalid invoking';
        this.types = [];
        this.tags = [];
        this.patterns = [];
    }
    pathToName(pathLike, suf = '') {
        const frags = pathLike.split('\\').join('/').split('/');
        return `${frags[frags.length - 1]}${suf}`;
    }
    readEntities(paths, fs) {
        return Promise.all(paths.map(async (p) => {
            try {
                return await fs.readJson(p);
            }
            catch (err) {
                return undefined;
            }
        }));
    }
    async itemParser(item, idx) {
        /* istanbul ignore next */
        if (!this.readUtils) {
            throw new Error(this.E_INVAL_INVO);
        }
        const [file, type] = this.getFileAndType(idx);
        const name = this.pathToName(file);
        const path = this.readUtils.fs.relativeToRoot(file);
        return { type, ref: path, name, path, tags: this.tags };
    }
    getFileAndType(idx) {
        /* istanbul ignore next */
        if (!this.readUtils) {
            throw new Error(this.E_INVAL_INVO);
        }
        return [
            this.readUtils.files[idx],
            this.defaultType,
        ];
    }
    get E_UNABLE_TO_READ() {
        return `Unable to read item of type ${this.defaultType}. `;
    }
    async read({ fs, matchedFiles }) {
        let files = [];
        for (const pattern of Object.keys(matchedFiles)) {
            const matchFiles = matchedFiles[pattern].sort();
            files = files.concat(matchFiles);
        }
        try {
            this.readUtils = { fs, files };
            const rawItems = await this.readEntities(files, fs);
            return Promise.all(rawItems.map(this.itemParser, this));
        }
        catch (err) {
            throw new Error(this.E_UNABLE_TO_READ);
        }
    }
}
exports.default = MdkItemReader;
//# sourceMappingURL=MdkItemReader.js.map
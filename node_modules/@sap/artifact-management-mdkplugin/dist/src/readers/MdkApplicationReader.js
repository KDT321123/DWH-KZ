"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MDK_APP_PATTERNS = void 0;
const artifact_management_base_1 = require("@sap/artifact-management-base");
const MdkItemReader_1 = __importDefault(require("./MdkItemReader"));
const InfoList_1 = require("../InfoList");
exports.MDK_APP_PATTERNS = ['Application.app'];
class MdkApplicationReader extends MdkItemReader_1.default {
    constructor() {
        super(...arguments);
        this.defaultType = artifact_management_base_1.ItemType.MDKApplication;
        this.types = [this.defaultType];
        this.tags = [artifact_management_base_1.Tag.Item, artifact_management_base_1.Tag.Application, artifact_management_base_1.Tag.MDK];
        this.matchConditions = {
            requiredFilePatterns: exports.MDK_APP_PATTERNS,
            dependentPatterns: ['Web/config.json'],
        };
    }
    async itemParser(app, idx) {
        if (!this.readUtils) {
            throw new Error(this.E_INVAL_INVO);
        }
        const [file, type] = this.getFileAndType(idx);
        const path = this.readUtils.fs.relativeToRoot(file);
        let name;
        const webConfigFile = 'Web/config.json';
        let info;
        artifact_management_base_1.Info;
        if (await this.readUtils.fs.fileExists(webConfigFile)) {
            try {
                const configJSON = await this.readUtils.fs.readJson(webConfigFile);
                if (configJSON.ApplicationDisplayName) {
                    name = configJSON.ApplicationDisplayName;
                }
            }
            catch {
                info = new artifact_management_base_1.Info();
                info.add(InfoList_1.InfoList.ERR_CONFIG_CORRUPT_FILE);
            }
        }
        else {
            info = new artifact_management_base_1.Info();
            info.add(InfoList_1.InfoList.ERR_CONFIG_MISSING);
        }
        if (!name) {
            name = (app ? app._Name : undefined) || this.pathToName(file);
        }
        const applicationLinks = [];
        const projectJSON = await this.readUtils.fs.readJson('.project.json');
        const item = {
            type, ref: path, name, path, tags: this.tags,
        };
        if (projectJSON.LCAP) {
            if (projectJSON.LCAP.sourceTemplate) {
                item.sourceTemplate = projectJSON.LCAP.sourceTemplate;
            }
            if (projectJSON.LCAP.Service) {
                for (const mdkInfo of projectJSON.LCAP.Service) {
                    //If there is '/' at the end of path inside LCAP.Service.cap.path, then we need to remove it so that it matches with service.cds @path
                    const ref = mdkInfo.cap.path.charAt(mdkInfo.cap.path.length - 1) === '/' ? mdkInfo.cap.path.slice(0, -1) : mdkInfo.cap.path;
                    applicationLinks.push({
                        linkType: artifact_management_base_1.LinkType.DEPENDS_ON,
                        type: artifact_management_base_1.ItemType.CAPService,
                        ref: ref,
                    });
                }
                item.links = applicationLinks;
            }
        }
        if (!app || !projectJSON.LCAP || (!projectJSON.LCAP.sourceTemplate || !projectJSON.LCAP.sourceTemplate.id)) {
            if (!info) {
                info = new artifact_management_base_1.Info();
            }
            if (!app) {
                info.add(InfoList_1.InfoList.ERR_CORRUPT_FILE);
            }
            else if (!projectJSON.LCAP) {
                info.add(InfoList_1.InfoList.ERR_LCAP_UNDEFINED);
            }
            else {
                info.add(InfoList_1.InfoList.ERR_SOURCETEMPLATE_ID_UNDEFINED);
            }
            item.info = info.getStateMessages();
        }
        return item;
    }
}
exports.default = MdkApplicationReader;
//# sourceMappingURL=MdkApplicationReader.js.map
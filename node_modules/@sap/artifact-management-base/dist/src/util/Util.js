"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const LoggerManager_1 = require("../logging/LoggerManager");
//import shallowEqual from "shallow-equal";
const util = require('util');
const exec = util.promisify(require('child_process').exec);
class Util {
    /* istanbul ignore next */
    static async exec(optionsOrCommand, ...commandAndArgs) {
        var _a, _b;
        let spawnOptions = { shell: false, stdio: 'inherit' };
        let command;
        let args;
        if (typeof optionsOrCommand === 'object') {
            spawnOptions = Object.assign({}, spawnOptions, optionsOrCommand);
            command = commandAndArgs[0];
            args = commandAndArgs.slice(1);
        }
        else {
            command = optionsOrCommand;
            args = commandAndArgs;
        }
        LoggerManager_1.getLogger().debug(`> ${[command].concat(args).map(arg => arg.match(/\s/) ? `"${arg}"` : arg).join(' ')}`);
        const childProcess = child_process_1.spawn(command, args, spawnOptions);
        let stdout;
        if ((_a = childProcess.stdout) === null || _a === void 0 ? void 0 : _a.on) {
            stdout = Buffer.from('');
            childProcess.stdout.on('data', chunk => stdout = Buffer.concat([stdout, Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk)]));
        }
        let stderr;
        if ((_b = childProcess.stderr) === null || _b === void 0 ? void 0 : _b.on) {
            stderr = Buffer.from('');
            childProcess.stderr.on('data', chunk => stderr = Buffer.concat([stderr, Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk)]));
        }
        await new Promise((resolve, reject) => {
            childProcess.on('exit', (code, signal) => {
                if (signal)
                    return reject(new Error(`Command terminated with signal ${signal}`));
                if (code !== 0)
                    return reject(new Error(`Command failed with return code ${code}`));
                resolve(true);
            });
            childProcess.on('error', (error) => {
                reject(error);
            });
        });
        return {
            stdout: stdout ? stdout.toString() : undefined,
            stderr: stderr ? stderr.toString() : undefined,
        };
    }
    static async execute(command, path) {
        const childProcess = await exec(command, { cwd: path });
        if (childProcess.stdout) {
            console.log(childProcess.stdout);
            LoggerManager_1.getLogger().info('stdout:', childProcess.stdout);
        }
        if (childProcess.stderr) {
            console.log(childProcess.stderr);
            LoggerManager_1.getLogger().error('stderr:', childProcess.stderr);
        }
        return {
            stdout: childProcess.stdout ? childProcess.stdout.toString() : undefined,
            stderr: childProcess.stderr ? childProcess.stderr.toString() : undefined,
        };
    }
    /* istanbul ignore next */
    static async commandLineExecutor(command) {
        return new Promise((resolve, reject) => {
            const childProcess = child_process_1.spawn(/^win/.test(process.platform) ? command.win : command.linux, command.args, command.options);
            let out = '';
            childProcess.stdout.on('data', data => {
                out += data;
            });
            childProcess.on('exit', () => resolve(out));
            childProcess.on('error', err => reject(err));
        });
    }
}
exports.default = Util;
//# sourceMappingURL=Util.js.map
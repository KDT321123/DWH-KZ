"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const LoggerManager_1 = require("../logging/LoggerManager");
const Util_1 = __importDefault(require("./Util"));
const fs = require('fs');
class NPMUtilClass {
    async globalRootPath() {
        if (!this.globalRootPathCache) {
            const command = {
                win: 'npm.cmd',
                linux: 'npm',
                args: ['root', '-g'],
            };
            const globalNodePath = await Util_1.default.commandLineExecutor(command);
            this.globalRootPathCache = globalNodePath.replace(/[\n\r]/g, '');
        }
        return this.globalRootPathCache;
    }
    async getCDSPath() {
        var _a;
        // We try to get the path to cds module in 3 ways. Only if one fails, we fall back to the next.
        // 1. Get cds path from "cds  -v".
        let cdsPath = undefined;
        if (!this.cdsPathCached) {
            const command = {
                win: 'cds.cmd',
                linux: 'cds',
                args: ['-v'],
            };
            const cdsOutputData = await Util_1.default.commandLineExecutor(command);
            // Check for path after "home: "
            // e.g :- home: /usr/local/lib/node_modules/@sap/cds --> /usr/local/lib/node_modules/@sap/cds
            cdsPath = ((_a = cdsOutputData.match(/home\:\s(.*)/)) === null || _a === void 0 ? void 0 : _a[1]) || '';
        }
        if (fs.existsSync(cdsPath) && this.assertCdsMinVersion(eval('require')(cdsPath))) {
            this.cdsPathCached = cdsPath;
            LoggerManager_1.getLogger().info(`Load @sap/cds module from cds -v' home: (${this.cdsPathCached})`);
            return this.cdsPathCached;
        }
        // 2. If cds was not present in previous path, 
        // try to get it from ${path-to-global-node-modules}/@sap/cds-dk/node_modules/@sap/cds
        cdsPath = await this.globalModulePath('@sap/cds-dk/node_modules/@sap/cds');
        // 3. If cds was not present in previous path, 
        // try to get it from ${path-to-global-node-modules}/@sap/cds
        if (this.cdsPathCached !== undefined && this.cdsPathCached !== '' && this.assertCdsMinVersion(eval('require')(cdsPath))) {
            this.cdsPathCached = cdsPath;
            LoggerManager_1.getLogger().info(`Load @sap/cds module from global @sap/cds-dk module (${this.cdsPathCached})`);
        }
        else {
            cdsPath = await this.globalModulePath('@sap/cds');
            if (this.cdsPathCached !== undefined && this.cdsPathCached !== '' && this.assertCdsMinVersion(eval('require')(cdsPath))) {
                this.cdsPathCached = cdsPath;
                LoggerManager_1.getLogger().info(`Load @sap/cds module from global module (${this.cdsPathCached})`);
            }
        }
        return this.cdsPathCached;
    }
    async globalModulePath(name) {
        const globalPath = await this.globalRootPath();
        if (globalPath !== undefined && globalPath !== '') {
            const modulePath = path_1.default.join(globalPath, name);
            if (fs.existsSync(modulePath)) {
                return modulePath;
            }
        }
        return globalPath;
    }
    assertCdsMinVersion(cds) {
        const [major, minor] = String(cds.version).split(/\./).map(component => parseInt(component, 10));
        if (major >= 5)
            return true;
        if (major === 4 && minor >= 3)
            return true;
        throw new Error(`@sap/cds version is too low: Expect 4.3.0 or higher, but found ${String(cds.version)}`);
    }
    async checkMTA() {
        let ret = false;
        const command = {
            win: 'mta.cmd',
            linux: 'mta',
            args: ['-v'],
        };
        try {
            const cdsOutputData = await Util_1.default.commandLineExecutor(command);
            ret = cdsOutputData && cdsOutputData.startsWith('MTA version');
        }
        catch (err) {
            //
        }
        return ret;
    }
    checkLocalPackage(packageName) {
        let pkg = undefined;
        try {
            pkg = require(packageName);
        }
        catch (err) {
            LoggerManager_1.getLogger().debug(`test ${packageName} failed.`);
        }
        return !!pkg;
    }
}
const NPMUtil = new NPMUtilClass();
exports.default = NPMUtil;
//# sourceMappingURL=NPMUtil.js.map
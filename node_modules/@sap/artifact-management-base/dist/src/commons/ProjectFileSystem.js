"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const js_yaml_1 = require("js-yaml");
const path_1 = require("path");
const path_2 = __importDefault(require("path"));
const ejs_1 = require("ejs");
const fast_glob_1 = __importDefault(require("fast-glob"));
const FastGlobFileSystemAdapter_1 = __importDefault(require("../fs/FastGlobFileSystemAdapter"));
const LoggerManager_1 = require("../logging/LoggerManager");
const parse_gitignore_1 = __importDefault(require("parse-gitignore"));
const ignore_1 = __importDefault(require("ignore"));
class ProjectFileSystem {
    constructor(basePath, rootPath) {
        this.basePath = basePath;
        this.rootPath = rootPath || basePath;
    }
    path(...paths) {
        return path_1.join(this.basePath, ...paths);
    }
    relativeToRoot(...paths) {
        return path_1.relative(this.rootPath, this.path(...paths));
    }
    relativeToRootFromAbsolutePath(...paths) {
        // For VSCodeFileSytem, the following line produces same result as Path.relativePath()
        // const path = this.vscode.workspace.asRelativePath(Path.join(...paths));
        return path_1.relative(this.makeAbsolute(this.rootPath), this.makeAbsolute(path_2.default.join(...paths)));
    }
    async readYaml(path) {
        const text = await this.readTextFile(path);
        return js_yaml_1.load(text);
    }
    getNewInstance(basePath, rootPath) {
        throw new Error('Method getInstance() not implemented.');
    }
    async readJson(path) {
        const text = await this.readTextFile(path);
        return JSON.parse(text);
    }
    async writeJSON(path, obj) {
        await this.writeTextFile(path, JSON.stringify(obj, null, 2));
    }
    async renderYamlTemplate(path, data) {
        const yamlText = await this.renderTemplate(path, data);
        const obj = js_yaml_1.load(yamlText);
        return obj;
    }
    async renderTemplate(path, data) {
        const template = await this.readTextFile(path);
        const text = ejs_1.render(template, data);
        return text;
    }
    async readFilesBFS({ ext } = {}) {
        const allFiles = [];
        const pendingDirs = [this];
        while (pendingDirs.length) {
            const fs = pendingDirs.shift();
            const [files, dirs] = await Promise.all([
                fs.readFiles({ ext }),
                fs.readDirectories(),
            ]);
            const relPrefix = path_1.relative(this.path(), fs.path());
            const relFiles = files.map(file => path_1.join(relPrefix, file));
            allFiles.push(...relFiles);
            pendingDirs.push(...dirs.map(dir => fs.navigate(dir)));
        }
        return allFiles;
    }
    isContained(path) {
        const absolutePath = this.makeAbsolute(path);
        const absoluteBasePath = this.makeAbsolute(this.basePath);
        return (absolutePath.startsWith(absoluteBasePath.endsWith(path_2.default.sep) ? absoluteBasePath : absoluteBasePath + path_2.default.sep));
    }
    makeAbsolute(path) {
        return path_2.default.normalize(path_2.default.isAbsolute(path) ? path : path_2.default.resolve(path));
    }
    getName(path, extension) {
        return path_2.default.basename(path, extension);
    }
    async glob(pattern, options) {
        const logEndOperation = LoggerManager_1.getLogger().profileOperation(`ProjectFileSystem.glob ${pattern}`);
        if (!this.filterFunction) {
            this.filterFunction = await this.gitIgnoreFileFilter();
        }
        this.globFilteringFileSystemAdapter = new FastGlobFileSystemAdapter_1.default(this.filterFunction);
        return await fast_glob_1.default(pattern, Object.assign({}, options, {
            cwd: this.path(),
            fs: this.globFilteringFileSystemAdapter,
        })).then((response) => {
            logEndOperation();
            return response;
        });
    }
    async gitIgnoreFileFilter() {
        const fs = this.getNewInstance(this.rootPath);
        let gitIgnoreText = '';
        if (await fs.fileExists('.gitignore')) {
            gitIgnoreText = await fs.readTextFile('.gitignore');
        }
        const gitIgnore = parse_gitignore_1.default(gitIgnoreText);
        const ig = ignore_1.default().add(gitIgnore);
        ig.add('.git/');
        return (path, isDir) => {
            const relativePath = path_2.default.relative(this.rootPath, path);
            if (isDir) {
                return !ig.ignores(path_2.default.join(relativePath, '*')); // workaround to exclude the whole directory
            }
            else {
                return !ig.ignores(relativePath);
            }
        };
    }
    deleteGlobFilter() {
        this.globFilteringFileSystemAdapter = undefined;
    }
    navigate(...paths) {
        throw new Error('Method not implemented.');
    }
    async stat(path) {
        throw new Error('Method not implemented.');
    }
    async fileExists(path) {
        throw new Error('Method not implemented.');
    }
    async directoryExists(path) {
        throw new Error('Method not implemented.');
    }
    async mkdir(path = '.', options) {
        throw new Error('Method not implemented.');
    }
    async readTextFile(path, absolutePath) {
        throw new Error('Method not implemented.');
    }
    async writeTextFile(path, str) {
        throw new Error('Method not implemented.');
    }
    async readDirectories() {
        throw new Error('Method not implemented.');
    }
    async readFiles({ ext } = {}) {
        throw new Error('Method not implemented.');
    }
    async rm(path, options) {
        throw new Error('Method not implemented.');
    }
}
exports.default = ProjectFileSystem;
//# sourceMappingURL=ProjectFileSystem.js.map
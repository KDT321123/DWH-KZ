"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const LoggerManager_1 = require("../logging/LoggerManager");
const NPMUtil_1 = __importDefault(require("../util/NPMUtil"));
const ErrorWithLocation_1 = __importDefault(require("../project/ErrorWithLocation"));
class CapApi {
    constructor(fs, paths) {
        this.fs = fs;
        this.paths = paths;
        this.csn = {
            all: function () {
                return [];
            },
        };
    }
    async cds() {
        if (!CapApi.cds) {
            if (typeof cds === 'object') {
                // If cds is already loaded, use the loaded cds module. It is not possible to load two different cds modules anyway.
                LoggerManager_1.getLogger().debug('Use already loaded cds instance');
                CapApi.cds = cds;
            }
            else {
                const cdsPath = await NPMUtil_1.default.getCDSPath();
                CapApi.cds = eval('require')(cdsPath);
                //Above is done to avoid warnings in webpack.
            }
        }
        NPMUtil_1.default.assertCdsMinVersion(CapApi.cds);
        return CapApi.cds;
    }
    async load(options) {
        const cds = await this.cds();
        let csnSource;
        try {
            let flavor = 'xtended';
            if (options && options.flavor) {
                flavor = options.flavor;
            }
            csnSource = await cds.compile.to.csn(this.paths.map(path => {
                const absPath = this.fs.path(path);
                const cached = cds.resolve.cache ? cds.resolve.cache[cds.root] : undefined;
                if (cached && cached.cached && cached.cached[absPath]) {
                    delete cached.cached[absPath];
                }
                return absPath;
            }), {
                flavor: flavor,
                cwd: '/',
            });
            this.csn = cds.reflect(csnSource);
        }
        catch (error) {
            const firstError = (error.errors || []).find((error) => error.severity === 'Error');
            if (firstError) {
                const firstErrorLocation = firstError.location || {};
                if (firstErrorLocation) {
                    error = new ErrorWithLocation_1.default({
                        message: error.message,
                        path: firstErrorLocation.file ? this.fs.relativeToRootFromAbsolutePath(firstErrorLocation.file) : '',
                        range: {
                            start: { line: firstErrorLocation.line, character: firstErrorLocation.col },
                            end: { line: firstErrorLocation.endLine, character: firstErrorLocation.endCol },
                        },
                    });
                }
            }
            LoggerManager_1.getLogger().error(error);
        }
    }
    services() {
        return this.csn.all('service');
    }
    entities() {
        return this.csn.all('entity');
    }
    async edmx(service) {
        const cds = await this.cds();
        const csnSource = await cds.compile.to.csn(this.paths.map(path => this.fs.path(path)), {
            flavor: 'inferred',
        });
        return await cds.compile.to.edmx(csnSource, { service });
    }
}
exports.default = CapApi;
//# sourceMappingURL=CapApi.js.map
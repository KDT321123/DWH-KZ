"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const artifact_management_base_1 = require("@sap/artifact-management-base");
const ItemSetInstance_1 = __importDefault(require("./ItemSetInstance"));
const ProjectEntityInstance_1 = __importDefault(require("./ProjectEntityInstance"));
const PluginFactory_1 = __importDefault(require("../definitions/PluginFactory"));
class ModuleInstance extends ProjectEntityInstance_1.default {
    constructor(watchManager, fs, readers) {
        super(watchManager, fs);
        this.readers = readers;
        this._type = 'ModuleInstance';
        readers.forEach(reader => {
            /* istanbul ignore if */
            if (PluginFactory_1.default.getModuleReaderFor(reader.getType()) === undefined) {
                PluginFactory_1.default.addModuleReader(reader);
            }
        });
        this.watchForChangesInModuleRootFolder();
    }
    /* istanbul ignore next */
    watchForChangesInModuleRootFolder() {
        //There are no watch patterns for say a directory thats created within a module. So explicitly adding this
        //so that we can track both create and delete of entities within the module and take necessary action.
        const pattern = (this.fs.relativeToRoot() === 'srv') ? ['{/*,external/*}'] : ['/*'];
        this.registerWatchPatterns(pattern, (event, file) => {
            artifact_management_base_1.getLogger().info(`Event in Module isntance - ${event} -- ${file} : BASEPATH: -- ${this.fs.basePath}`);
            if (event === artifact_management_base_1.EventType.ADD || event === artifact_management_base_1.EventType.ADD_DIR || event === artifact_management_base_1.EventType.DELETE_DIR) {
                //If data is found for module then respective regexes are automatically applied.
                //Only when folder is empty to start with then, its not known its even which module type
                //so adding the regex of '*' at basepath of this folder so that its data(undefined) gets invalidated.
                artifact_management_base_1.getLogger().info(`Invalidating cache for -- ${this.fs.basePath}`);
                this.invalidate();
            }
        });
    }
    getFs() {
        return this.fs;
    }
    async loadItemSets(moduleData) {
        if (!moduleData)
            return [];
        const itemSets = [];
        const moduleReader = PluginFactory_1.default.getModuleReaderFor(moduleData.type);
        const itemReaders = moduleReader.itemReaders;
        for (const itemReader of itemReaders) {
            itemSets.push(new ItemSetInstance_1.default(this.watchManager, this.fs, itemReader));
        }
        return itemSets;
    }
    async getData() {
        return this.getDataCached({
            load: async () => {
                return await this.loadByReaders(this.readers);
            },
            onDataChanged: () => this.unloadChildren(),
        });
    }
    async getItemSets() {
        // Call getData() outside of getChildCache load method to ensure its updated and invalidate children in case of data change
        const moduleData = await this.getData();
        return this.getChildCached({
            name: 'itemSets',
            load: async () => this.loadItemSets(moduleData),
        });
    }
    async getModuleType() {
        const moduleData = await this.getData();
        if (moduleData !== undefined && moduleData.type !== undefined) {
            return moduleData.type;
        }
        else {
            return '';
        }
    }
    async getItems() {
        const itemSets = await this.getItemSets();
        let items = [];
        const info = new artifact_management_base_1.Info();
        for (const itemSet of itemSets) {
            try {
                artifact_management_base_1.getLogger().debug(`getting Module Item Type - ${itemSet.getItemReader().types} - Pattern - ${JSON.stringify(itemSet.getItemReader().matchConditions)}`);
                items = items.concat(await itemSet.getItems() || []);
                itemSet.tags = this.tags;
            }
            catch (error) {
                const moduleType = await this.getModuleType();
                info.add(error, moduleType);
            }
        }
        return { items, info: info.getStateMessages() };
    }
}
exports.default = ModuleInstance;
//# sourceMappingURL=ModuleInstance.js.map
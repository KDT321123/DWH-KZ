"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const xml2js_1 = __importDefault(require("xml2js"));
const uuid_1 = require("uuid");
class DataFirstUtil {
    constructor(projectImpl) {
        this.projectImpl = projectImpl;
    }
    async parseCSVFile(path, absolutePath) {
        const entityName = '';
        const contents = await this.projectImpl.fs().readTextFile(path, absolutePath);
        const data = [
            {
                entity: entityName,
                labels: [],
                props: Array(),
                values: Array(),
            },
        ];
        const lines = contents.split('\n');
        const valueMatrix = [];
        lines.forEach((line, lineIndex) => {
            line = line.replace('\r', '');
            if (line.trim().length > 0) {
                const values = line.split(/;|,/);
                data[0] = this.processValues(values, lineIndex, data[0]);
                if (lineIndex > 0) {
                    const processedValues = data[0].values[lineIndex - 1];
                    valueMatrix.push(processedValues.map((value, eleIndex) => {
                        if (data[0].props[eleIndex] && data[0].props[eleIndex].type === 'UUID') {
                            return {
                                value: value,
                                type: 'UUID',
                            };
                        }
                        else {
                            let type = 'String';
                            try {
                                const jsType = typeof JSON.parse(value.toLowerCase());
                                type = this.getJsDataType(value, jsType);
                            }
                            catch (error) { }
                            return {
                                value: value,
                                type: value ? type : undefined,
                            };
                        }
                    }));
                }
            }
        });
        this.processDataTypes(valueMatrix, data[0]);
        return data;
    }
    async parseXMLFile(path, absolutePath) {
        const parser = new xml2js_1.default.Parser();
        // read xml file originating from excel
        const contents = await this.projectImpl.fs().readTextFile(path, absolutePath);
        const data = [];
        parser.parseString(contents, (err, result) => {
            result.Workbook.Worksheet.forEach((worksheet, entityIndex) => {
                //each worksheet is a new entity
                let entity = {
                    entity: worksheet.$['ss:Name'],
                    labels: [],
                    props: [],
                    values: [],
                };
                const valueMatrix = [];
                worksheet.Table[0].Row.forEach((row, rowIndex) => {
                    const values = [];
                    const valueTypes = [];
                    row.Cell.forEach((cell, itemIndex) => {
                        const value = cell.Data[0]._;
                        const ssIndex = cell.$ && cell.$['ss:Index'];
                        if (ssIndex) {
                            try {
                                // process empty cells middle of each row
                                const cellIndex = JSON.parse(ssIndex);
                                if (cellIndex && cellIndex - 1 > itemIndex) {
                                    for (let k = itemIndex; k < cellIndex - 1; k++) {
                                        values.push('');
                                        if (rowIndex > 0) {
                                            valueTypes.push({
                                                value: '',
                                                type: undefined,
                                            });
                                        }
                                    }
                                }
                            }
                            catch (error) {
                            }
                        }
                        values.push(value);
                        if (rowIndex > 0) {
                            valueTypes.push({
                                value: value,
                                type: this.getExcelDataType(value, cell.Data[0].$ && cell.Data[0].$['ss:Type']),
                            });
                        }
                    });
                    // process empty cells at the end of each row
                    if (rowIndex > 0 && values.length < entity.labels.length) {
                        for (let i = values.length; i < entity.labels.length; i++) {
                            values.push('');
                            valueTypes.push({
                                value: '',
                                type: undefined,
                            });
                        }
                    }
                    entity = this.processValues(values, rowIndex, entity);
                    if (rowIndex > 0) {
                        valueMatrix.push(valueTypes);
                    }
                });
                data.push(entity);
                this.processDataTypes(valueMatrix, entity);
            });
            // check for associations
            if (data.length > 1) {
                data.forEach((entity, entityIndex) => {
                    entity.props = entity.props.map((prop, propIndex) => {
                        if (!this.isId(prop.name)) {
                            for (let i = 0; i < data.length; i++) {
                                if (i === entityIndex) {
                                    continue;
                                }
                                // check whether first property of each other entities has the same name as the current property.
                                if (data[i].props[0].name === prop.name) {
                                    data[i].props[0].key = 'true';
                                    //this is an association, point to it
                                    prop.kind = 'association';
                                    prop.dataType = data[i].entity;
                                    prop.noOfValues = data[i].values.length;
                                    delete prop.type;
                                    //if there is a second property in the associated entity, its value is going to be displayed instead of the id
                                    if (data[i].props.length > 1) {
                                        prop.displayProperty = data[i].props[1].name;
                                    }
                                    else {
                                        prop.displayProperty = data[i].props[0].name;
                                    }
                                    //db name is a concatenation of the property name and the key of the association entity in CAP
                                    data[entityIndex].dbProps[propIndex] = prop.name + '_' + data[i].props[0].name;
                                }
                            }
                        }
                        return prop;
                    });
                });
            }
        });
        return this.alignAssociationProps(data);
    }
    setMainEntity(data, mainEntityName) {
        if (data && data.length) {
            if (data.length === 1 && mainEntityName && !data[0].entity) {
                data[0].entity = mainEntityName;
            }
            const entityName = mainEntityName || data[0].entity;
            for (let index = 0; index < data.length; index++) {
                const entity = data[index];
                if (entity.entity === entityName) {
                    const foundKey = !!entity.props.find((prop) => prop.key === 'true');
                    const foundID = !!entity.labels.find((label) => this.isId(label.label));
                    if (!foundKey) {
                        if (!foundID) {
                            // insert ID for main entity
                            entity.labels.unshift({
                                label: 'ID',
                                value: 'ID',
                            });
                            entity.props.unshift({
                                name: 'ID',
                                kind: 'dataType',
                                type: 'UUID',
                                key: 'true',
                                isComputed: 'true',
                            });
                            entity.dbProps.unshift('ID');
                            entity.values.forEach((value) => value.unshift(uuid_1.v4()));
                            break;
                        }
                        else {
                            this.setKeyColumn(entity);
                        }
                    }
                }
            }
        }
    }
    processDataTypes(valueMatrix, data) {
        for (let lineIndex = 0; lineIndex < valueMatrix.length; lineIndex++) {
            const line = valueMatrix[lineIndex];
            for (let eleIndex = 0; eleIndex < line.length; eleIndex++) {
                const ele = line[eleIndex];
                const prop = ele.value.toLowerCase().replace(/ /g, '_');
                data.props[eleIndex] = data.props[eleIndex] || {
                    name: prop,
                    kind: 'dataType',
                    key: 'false',
                };
                let curType = data.props[eleIndex].type;
                if (curType) {
                    if (curType !== 'UUID') {
                        if (!ele.type) {
                            data.props[eleIndex]['hasNull'] = true;
                        }
                        else if (curType !== ele.type) {
                            if (curType === 'Integer' && ele.type === 'Double') {
                                curType = 'Double';
                            }
                            else if (curType === 'Double' && ele.type === 'Integer') {
                            }
                            else {
                                curType = 'String';
                            }
                        }
                    }
                }
                else {
                    curType = ele.type;
                }
                data.props[eleIndex].type = curType;
            }
        }
        this.normalizeValues(data);
    }
    processValues(values, index, data) {
        if (index === 0) {
            // first line in csv are properties
            data.dbProps = [];
            values.forEach((value) => {
                // properties derived from labels: only lower case letters and no spaces
                value = value.trimLeft();
                const prop = this.isId(value) ? value : value.toLowerCase().replace(/ /g, '_');
                data.labels.push({
                    label: value,
                    value: prop,
                });
                data.props.push({
                    name: prop,
                    kind: 'dataType',
                    type: undefined,
                    key: 'false',
                });
                //db property is noramly the property name in the entity
                data.dbProps.push(prop);
            });
        }
        else {
            // all other lines are data values
            data.values.push(values);
        }
        return data;
    }
    normalizeValues(data) {
        for (let i = 0; i < data.props.length; i++) {
            const prop = data.props[i];
            prop.type = prop.type || 'String';
            if (prop.type === 'Boolean') {
                data.values.forEach((line) => {
                    const value = line[i];
                    if (value) {
                        if (value === '0') {
                            line[i] = 'false';
                        }
                        else if (value === '1') {
                            line[i] = 'true';
                        }
                        else {
                            line[i] = value.toLowerCase();
                        }
                    }
                });
                return;
            }
        }
    }
    setKeyColumn(data) {
        for (let i = 0; i < data.props.length; i++) {
            const prop = data.props[i];
            if (this.isId(prop.name) && prop.key !== 'true') {
                prop.key = 'true';
                if (prop.type === 'Integer') {
                    prop.isComputed = 'true';
                }
                else if (prop.type === 'String') {
                    if (this.checkIfUUIDColumn(i, data)) {
                        prop.type = 'UUID';
                        prop.isComputed = 'true';
                    }
                }
            }
        }
    }
    alignAssociationProps(data) {
        if (data.length > 0) {
            data.forEach((entity) => {
                const assProps = [];
                if (this.propsNeedAligned(entity.props, assProps)) {
                    if (assProps.length > 0) {
                        assProps.forEach((propIndex, index) => {
                            const realIndex = propIndex - index;
                            if (realIndex >= 0) {
                                entity.props.push(entity.props.splice(realIndex, 1)[0]);
                                entity.labels.push(entity.labels.splice(realIndex, 1)[0]);
                                entity.dbProps.push(entity.dbProps.splice(realIndex, 1)[0]);
                                entity.values.forEach((line) => {
                                    line.push(line.splice(realIndex, 1)[0]);
                                });
                            }
                        });
                    }
                }
            });
        }
        return data;
    }
    propsNeedAligned(props, assProps) {
        let foundAssProp = false;
        let needAligned = false;
        if (props && props.length > 0) {
            for (let i = 0; i < props.length; i++) {
                if (props[i].kind === 'association') {
                    foundAssProp = true;
                    assProps.push(i);
                }
                // all association props should be at the end
                if (foundAssProp && props[i].kind !== 'association') {
                    needAligned = true;
                }
            }
        }
        return needAligned;
    }
    getJsDataType(value, type) {
        switch (type) {
            case 'boolean':
                return 'Boolean';
            case 'number':
                return value.indexOf('.') >= 0 ? 'Double' : 'Integer';
            default:
                return type ? 'String' : type;
        }
    }
    getExcelDataType(value, type) {
        switch (type) {
            case 'Number':
                return value.indexOf('.') >= 0 ? 'Double' : 'Integer';
            case 'Boolean':
            case 'String':
                return type;
            default:
                return type ? 'String' : type;
        }
    }
    checkIfUUIDColumn(index, data) {
        const reUUID = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
        if (data.values && data.values.length > 0) {
            for (let i = 0; i < data.values.length; i++) {
                const value = data.values[i][index];
                if (value && value.match(reUUID)) {
                    continue;
                }
                else {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    isId(value) {
        return !!value && value.toUpperCase() === 'ID';
    }
}
exports.default = DataFirstUtil;
//# sourceMappingURL=DataFirstUtil.js.map
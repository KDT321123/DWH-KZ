"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const artifact_management_base_1 = require("@sap/artifact-management-base");
const ModuleInstance_1 = __importDefault(require("./ModuleInstance"));
const ProjectEntityInstance_1 = __importDefault(require("./ProjectEntityInstance"));
const PluginFactory_1 = __importDefault(require("../definitions/PluginFactory"));
const path_1 = __importDefault(require("path"));
const lodash_1 = __importDefault(require("lodash"));
/**
 * Module directories of the project
 */
class ProjectModulesInstance extends ProjectEntityInstance_1.default {
    constructor(watchManager, fs, projectData, readModuleAsProject = false) {
        super(watchManager, fs);
        this.projectData = projectData;
        this._type = 'ProjectModulesInstance';
        this.readModuleAsProject = readModuleAsProject;
    }
    async loadModuleDirectories() {
        artifact_management_base_1.getLogger().info('Cache miss in getting Directory list invoking ProjectModuleInstance.loadModuleDirectories');
        let allFolders = [];
        const watchPatterns = [];
        const reader = PluginFactory_1.default.getProjectReaderFor(this.projectData.type, this.readModuleAsProject);
        const moduleSearchPatterns = await reader.moduleSearchPattern();
        /* istanbul ignore if */
        if (this.readModuleAsProject && reader instanceof artifact_management_base_1.ProjectWrapper) {
            const folder = this.fs.basePath.split('/').pop();
            if (folder) {
                allFolders.push(folder);
            }
        }
        else {
            for (const dirPattern of moduleSearchPatterns) {
                watchPatterns.push(dirPattern);
                const folders = await this.fs.glob(dirPattern, { onlyDirectories: true });
                allFolders = allFolders.concat(folders);
            }
        }
        //this.registerWatchPatterns(watchPatterns);
        //Not doing the above as in base class getDataCached method this is anyways happening.
        artifact_management_base_1.getLogger().info('Directories to be read ->' + JSON.stringify(allFolders));
        return { data: allFolders, watchPatterns };
    }
    async loadModuleInstances(directoryPaths) {
        artifact_management_base_1.getLogger().info('Cache miss. Entering ProjectModuleInstance.loadModuleInstance()');
        const moduleDirectoryInstances = [];
        const reader = PluginFactory_1.default.getProjectReaderFor(this.projectData.type, this.readModuleAsProject);
        for (const directoryPath of directoryPaths) {
            let moduleFs;
            // if this.readModuleAsProject is true and is not CAP project, then current project folder is to be considered as module. 
            // So, not navigating to inner folders in that case
            /* istanbul ignore if */
            if (this.readModuleAsProject && reader instanceof artifact_management_base_1.ProjectWrapper) {
                moduleFs = this.fs.navigate();
            }
            else {
                moduleFs = this.fs.navigate(directoryPath);
            }
            moduleDirectoryInstances.push(new ModuleInstance_1.default(this.watchManager, moduleFs, PluginFactory_1.default.getModuleReaders()));
        }
        for (const additionalReaders of reader.additionalModuleReaders) {
            moduleDirectoryInstances.push(new ModuleInstance_1.default(this.watchManager, this.fs, additionalReaders));
        }
        return moduleDirectoryInstances;
    }
    async getModules() {
        const moduleDatas = [];
        for (const moduleInstance of await this.getModuleInstances()) {
            const moduleData = await moduleInstance.getData();
            if (moduleData) {
                moduleDatas.push(moduleData);
            }
        }
        return moduleDatas;
    }
    async readDeep() {
        artifact_management_base_1.getLogger().debug('Entering ProjectModuleInstance.readDeep()');
        const moduleInstances = await this.getModuleInstances();
        const modules = [];
        for (const moduleInstance of moduleInstances) {
            let moduleData;
            try {
                moduleData = await moduleInstance.getData();
                if (moduleData && moduleData.tags) {
                    moduleInstance.tags = moduleData.tags;
                }
            }
            catch (error) {
                const info = new artifact_management_base_1.Info().add(error);
                moduleData = {
                    name: this.fs.basePath,
                    info: info.getStateMessages(),
                };
            }
            artifact_management_base_1.getLogger().debug(`read data for module - ${moduleInstance.getFs().basePath} - Data: ${JSON.stringify(moduleData)}`);
            if (moduleData) {
                const itemsData = await moduleInstance.getItems();
                const items = itemsData.items;
                const itemsInfo = itemsData.info;
                artifact_management_base_1.getLogger().debug(`read Item data for module - ${moduleInstance.getFs().basePath} - ItemData: ${JSON.stringify(items)}`);
                const data = Object.assign({}, moduleData, { items });
                /* istanbul ignore if */
                if (itemsInfo) {
                    data.info = itemsInfo;
                }
                modules.push(data);
            }
        }
        return Object.assign({}, lodash_1.default.cloneDeep(this.projectData), { modules });
    }
    async getModuleDirectories() {
        return this.getDataCached({
            load: async () => this.loadModuleDirectories(),
            onDataChanged: () => this.unloadChildren(),
        });
    }
    async getModuleInstances() {
        // Call getModuleDirectories() outside of getChildCache load method to ensure its updated and invalidate children in case of data change
        const directoryPaths = await this.getModuleDirectories();
        return this.getChildCached({
            name: 'moduleDirectories',
            load: async () => this.loadModuleInstances(directoryPaths),
        });
    }
    async readItems(filter) {
        artifact_management_base_1.getLogger().debug(`Entering ProjectModuleInstance.readItems() - filter - ${JSON.stringify(filter)}`);
        const items = [];
        if (filter) {
            const filterImpl = new artifact_management_base_1.ItemFilterImpl(filter);
            if (filter.tags && filter.tags.values.length > 0) {
                const itemsFilteredByTags = await this.getItemsFilteredByTags(filter.tags);
                artifact_management_base_1.getLogger().debug('FilteredByTags Response: ' + JSON.stringify(itemsFilteredByTags, null, 2));
                for (const item of itemsFilteredByTags || []) {
                    /* istanbul ignore else */
                    if (filterImpl.match(item)) {
                        delete item.links;
                        items.push(item);
                    }
                }
            }
            else {
                try {
                    const project = await this.readDeep();
                    artifact_management_base_1.getLogger().debug('Project Response: ' + JSON.stringify(project, null, 2));
                    artifact_management_base_1.getLogger().debug('Filtering will be done by types.');
                    /* istanbul ignore if */
                    if (!project)
                        return [];
                    for (const module of project.modules || []) {
                        for (const item of module.items || []) {
                            if (filterImpl.match(item)) {
                                delete item.links;
                                items.push(item);
                            }
                        }
                    }
                }
                catch (error) {
                    artifact_management_base_1.getLogger().error('Error occurred while readItems of project - ', error);
                    return [];
                }
            }
        }
        else {
            artifact_management_base_1.getLogger().info('No filtering. Need to return all Items');
            const project = await this.readDeep();
            artifact_management_base_1.getLogger().info('Project Read Done.');
            artifact_management_base_1.getLogger().debug('Project Response: ' + JSON.stringify(project, null, 2));
            /* istanbul ignore if */
            if (!project)
                return [];
            const itemMap = {};
            for (const module of project.modules || []) {
                for (const item of module.items || []) {
                    const key = `${item.type}:${item.ref}`;
                    itemMap[key] = item;
                    items.push(item);
                }
            }
            for (const item of items) {
                for (const link of item.links || []) {
                    const targetKey = `${link.type}:${link.ref}`;
                    const targetItem = itemMap[targetKey];
                    /* istanbul ignore if */
                    if (!targetItem) {
                        /*
                        @todo: Log error
                        MessageUtil.addMessageTo(item, new ErrorWithLocation({
                            message: `Missing item "${link.type}:${link.ref}" that is required by "${item.type}:${item.ref}".`,
                            path: item.path,
                        })));
                        */
                        continue;
                    }
                    if (!targetItem.links)
                        targetItem.links = [];
                    if (artifact_management_base_1.isLinkTypeReverseValid(link.linkType)) {
                        const reverseLink = {
                            linkType: artifact_management_base_1.LinkTypeReverse[link.linkType],
                            type: item.type,
                            ref: item.ref,
                        };
                        /* istanbul ignore if */
                        if (targetItem.links.find((link) => link.linkType === reverseLink.linkType &&
                            link.type === reverseLink.type && link.ref === reverseLink.ref))
                            continue;
                        targetItem.links.push(reverseLink);
                    }
                }
            }
        }
        artifact_management_base_1.getLogger().debug(JSON.stringify(items, null, 2));
        artifact_management_base_1.getLogger().debug(`Exiting ProjectModuleInstance.readItems() - filter - ${JSON.stringify(filter)}`);
        return items;
    }
    async getItemsFilteredByTags(tags) {
        artifact_management_base_1.getLogger().debug('Entering ProjectModuleInstance.getItemsFilteredByTags()');
        let items = [];
        let moduleReaders = PluginFactory_1.default.getModuleReaders();
        //To check for additional module readers and add it to module readers
        const projectReaders = PluginFactory_1.default.getProjectReaders(this.readModuleAsProject);
        for (const reader of projectReaders) {
            /* istanbul ignore else */
            if (reader.additionalModuleReaders) {
                moduleReaders = moduleReaders.concat(...reader.additionalModuleReaders);
            }
        }
        const requiredModuleReaders = [];
        // Find all the item reader which match the tags
        for (let i = 0; i < moduleReaders.length; i++) {
            const moduleReader = moduleReaders[i];
            const itemReaders = moduleReader.itemReaders;
            const requiredItemReaders = [];
            for (let j = 0; j < itemReaders.length; j++) {
                const itemReader = itemReaders[j];
                // Check if Item should be filtered based on having all the tags or any of the tags.
                /* istanbul ignore else */
                if (tags.matchCriteria === artifact_management_base_1.FilterMatchCriteria.ALL) {
                    if (tags.values.every(val => itemReader.tags.includes(val))) {
                        requiredItemReaders.push(itemReader);
                    }
                }
                else {
                    if (tags.values.some(val => itemReader.tags.includes(val))) {
                        requiredItemReaders.push(itemReader);
                    }
                }
                // If there are requiredItemReaders, then push only those to the respective moduleReaders that matches the filterCriteria
                if (requiredItemReaders.length > 0) {
                    moduleReader.itemReaders = requiredItemReaders;
                    if (!requiredModuleReaders.includes(moduleReader)) {
                        requiredModuleReaders.push(moduleReader);
                    }
                }
            }
        }
        // Iterate through all the directories and read with the matched readers.
        const directories = await this.getModuleDirectories();
        // Even root directory has to be iterated for any items.
        directories.push('');
        for (const directory of directories) {
            const modulefs = this.fs.navigate(directory);
            const moduleInstance = new ModuleInstance_1.default(this.watchManager, modulefs, requiredModuleReaders);
            const itemData = await moduleInstance.getItems();
            /* istanbul ignore else */
            if (itemData.items) {
                items = items.concat(itemData.items);
            }
        }
        return items;
    }
    async detailInfo(type, ref, entityPath, options) {
        artifact_management_base_1.getLogger().debug(`Entering ProjectModuleInstance.detailInfo() - type - ref - ${JSON.stringify(type + ref)}`);
        /* istanbul ignore else */
        if (!entityPath) {
            const refs = [ref];
            const filter = (refs === null || refs === void 0 ? void 0 : refs.length) ? { refs } : undefined;
            const items = await this.readItems(filter);
            /* istanbul ignore else */
            if (items.length) {
                entityPath = path_1.default.join(this.fs.rootPath, items[0].path.split('/')[0]);
            }
            else {
                return undefined;
            }
        }
        else {
            if (await this.fs.fileExists(entityPath)) {
                entityPath = path_1.default.join(this.fs.rootPath, entityPath.split('/')[0]);
            }
            else {
                throw new Error(`Invalid path: ${entityPath}`);
            }
        }
        const fsPath = artifact_management_base_1.FileSystemFactory.getFileSystem(entityPath, this.fs.rootPath);
        const itemReader = PluginFactory_1.default.getItemReaderFor(type);
        const requiredItems = itemReader.detailInfo ? await itemReader.detailInfo(fsPath, ref, options) : undefined;
        artifact_management_base_1.getLogger().debug('Detail Info Done.');
        return requiredItems;
    }
}
exports.default = ProjectModulesInstance;
//# sourceMappingURL=ProjectModulesInstance.js.map
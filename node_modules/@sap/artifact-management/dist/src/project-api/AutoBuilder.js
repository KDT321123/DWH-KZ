"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const CallDeferred_1 = __importDefault(require("../commons/CallDeferred"));
const artifact_management_base_1 = require("@sap/artifact-management-base");
const PluginFactory_1 = __importDefault(require("../definitions/PluginFactory"));
class AutoBuilder extends events_1.EventEmitter {
    constructor(fs, fileSystemWatchManager, project) {
        super();
        this.fs = fs;
        this.fileSystemWatchManager = fileSystemWatchManager;
        this.project = project;
        this.moduleAutoBuilder = {};
        this.callUpdateModules = CallDeferred_1.default.create({ func: () => this.updateModules(), triggerDelay: 5, maxTriggerDelay: 500, recallDelay: 1000 });
    }
    async start() {
        // @todo: Needs to be changed to a module watch that does not yet exists otherwise each item change will trigger the invalidate
        this.fileSystemWatchManager.on('change', this.callUpdateModules);
        this.callUpdateModules();
    }
    async destroy() {
        this.fileSystemWatchManager.removeListener('change', this.callUpdateModules);
        for (const moduleType of Object.getOwnPropertyNames(this.moduleAutoBuilder)) {
            const entry = this.moduleAutoBuilder[moduleType];
            this.fileSystemWatchManager.removeFileSystemWatcher(entry.observers);
        }
        this.moduleAutoBuilder = {};
        this.emit('destroy', this);
    }
    /* istanbul ignore next */
    async updateModules() {
        artifact_management_base_1.getLogger().info('Entering AutoBuilder.updateModules()');
        // @todo: ensure metho
        const modules = await this.project.readModules();
        const oldEntries = this.moduleAutoBuilder;
        const newEntries = {};
        const createdEntries = [];
        for (const module of modules) {
            if (newEntries[module.type])
                continue;
            if (oldEntries[module.type]) {
                newEntries[module.type] = oldEntries[module.type];
                delete oldEntries[module.type];
                continue;
            }
            try {
                const autoBuilder = PluginFactory_1.default.getModuleBuilderFor(module.type);
                artifact_management_base_1.getLogger().info(`Autobuilder now watching for pattern ${autoBuilder.patterns}`);
                const entry = newEntries[module.type] = {
                    autoBuilder,
                    observers: this.fileSystemWatchManager.createFileSystemWatcher(this.fs, autoBuilder.patterns(), () => autoBuilder.runUpdate(this.fs, this.project)),
                };
                newEntries[module.type] = entry;
            }
            catch (error) {
                if (error instanceof artifact_management_base_1.PluginNotFoundError)
                    continue;
                throw error;
            }
            createdEntries.push(newEntries[module.type]);
        }
        this.moduleAutoBuilder = newEntries;
        for (const moduleType of Object.getOwnPropertyNames(oldEntries)) {
            const entry = oldEntries[moduleType];
            this.fileSystemWatchManager.removeFileSystemWatcher(entry.observers);
        }
        for (const plugin of createdEntries) {
            await plugin.autoBuilder.runInitial(this.fs, this.project);
        }
    }
}
exports.default = AutoBuilder;
//# sourceMappingURL=AutoBuilder.js.map
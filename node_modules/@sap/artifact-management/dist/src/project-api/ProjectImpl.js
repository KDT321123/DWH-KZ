"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const artifact_management_base_1 = require("@sap/artifact-management-base");
const ProjectInstance_1 = require("./ProjectInstance");
const ItemWatcher_1 = __importDefault(require("./ItemWatcher"));
const AutoBuilder_1 = __importDefault(require("./AutoBuilder"));
const LocalFileSystemWatchManager_1 = __importDefault(require("./LocalFileSystemWatchManager"));
const PlatformContext_1 = require("../project/PlatformContext");
const BuildFactory_1 = __importDefault(require("../definitions/BuildFactory"));
const PluginFactory_1 = __importDefault(require("../definitions/PluginFactory"));
const DataFirstUtil_1 = __importDefault(require("./DataFirstUtil"));
const urlFileName = '.application_summary';
const statusTrackerFileName = '.status_tracker';
class ProjectImpl {
    constructor(path, readModuleAsProject = false, useHeadlessGenerator) {
        this.watchClients = new Map();
        this.path = path;
        this.readModuleAsProject = readModuleAsProject;
        this.useHeadlessGenerator = useHeadlessGenerator ? true : false;
    }
    async autoBuild(logger = artifact_management_base_1.noopLogger) {
        const logInst = new artifact_management_base_1.ProjectAPILogger(logger.getChildLogger({ label: 'autoBuild' }));
        artifact_management_base_1.setLogger(logInst);
        const endProfile = logInst.profileOperation('ProjectApi.autoBuild');
        artifact_management_base_1.FileSystemFactory.init();
        this.startWatch();
        const autoBuilder = new AutoBuilder_1.default(this.fs(), this.watchManager, this.projectInstance());
        this.watchClients.set(autoBuilder, autoBuilder);
        autoBuilder.on('destroy', obj => this.stopWatch(obj));
        endProfile();
        return autoBuilder;
    }
    projectInstance() {
        if (this.cachedProjectInstance)
            return this.cachedProjectInstance;
        else {
            this.watchManager = new LocalFileSystemWatchManager_1.default(this.fs().path());
            this.cachedProjectInstance = new ProjectInstance_1.ProjectInstance(this.watchManager, this.fs(), this.readModuleAsProject);
            return this.cachedProjectInstance;
        }
    }
    /**
     * Read project, its modules and entities
     *
     */
    async read(logger = artifact_management_base_1.noopLogger, tag) {
        const logInst = new artifact_management_base_1.ProjectAPILogger(logger.getChildLogger({ label: 'read' }));
        artifact_management_base_1.setLogger(logInst);
        const endProfile = logInst.profileOperation('ProjectApi.read');
        artifact_management_base_1.FileSystemFactory.init();
        return this.projectInstance()
            .readDeep(tag)
            .then((response) => {
            this.path = this.projectInstance().getPath();
            endProfile();
            return response;
        });
    }
    /**
     * Watch items
     *
     */
    async watchItems(filter, logger = artifact_management_base_1.noopLogger) {
        const logInst = new artifact_management_base_1.ProjectAPILogger(logger.getChildLogger({ label: 'read' }));
        artifact_management_base_1.setLogger(logInst);
        const endProfile = logInst.profileOperation('ProjectApi.watchItems');
        artifact_management_base_1.FileSystemFactory.init();
        this.startWatch();
        const itemWatcher = new ItemWatcher_1.default(this.projectInstance(), this.watchManager, filter);
        this.watchClients.set(itemWatcher, itemWatcher);
        itemWatcher.on('destroy', obj => this.stopWatch(obj));
        endProfile();
        return itemWatcher;
    }
    startWatch() {
        if (!this.cachedProjectInstance) {
            this.projectInstance();
        }
        this.watchManager.enable();
        return this.watchManager;
    }
    stopWatch(obj) {
        this.watchClients.delete(obj);
        if (!this.watchClients.has(obj) && this.watchManager) {
            this.watchManager.disable();
            this.cachedProjectInstance = undefined;
        }
    }
    /**
     * Read project, its modules and entities
     *
     */
    async tryRead() {
        const project = await this.read();
        if (!project) {
            throw new Error(`"${this.path}" doesn't contain a development project.`);
        }
        return project;
    }
    fs() {
        return artifact_management_base_1.FileSystemFactory.getFileSystem(this.path);
    }
    /**
     * Read entities provided by the project
     *
     * @param filter
     */
    async readItems(filter, logger = artifact_management_base_1.noopLogger) {
        const logInst = new artifact_management_base_1.ProjectAPILogger(logger.getChildLogger({ label: 'readItems' }));
        artifact_management_base_1.setLogger(logInst);
        const endProfile = logInst.profileOperation('ProjectApi.readItems');
        artifact_management_base_1.FileSystemFactory.init();
        return this.projectInstance()
            .readItems(filter)
            .then((response) => {
            this.path = this.projectInstance().getPath();
            endProfile();
            return response;
        });
    }
    /**
     * Read detail information for the required type and ref provided by the project
     *
     * @param type
     * @param ref
     */
    async getDetailInfo(type, ref, entityPath, options, logger = artifact_management_base_1.noopLogger) {
        const logInst = new artifact_management_base_1.ProjectAPILogger(logger.getChildLogger({ label: 'getDetailInfo' }));
        artifact_management_base_1.setLogger(logInst);
        const endProfile = logInst.profileOperation('ProjectApi.getDetailInfo');
        artifact_management_base_1.FileSystemFactory.init();
        return this.projectInstance()
            .detailInfo(type, ref, entityPath, options)
            .then((response) => {
            endProfile();
            return response;
        });
    }
    async run(options, logger = artifact_management_base_1.noopLogger) {
        const logInst = new artifact_management_base_1.ProjectAPILogger(logger.getChildLogger({ label: 'run' }));
        artifact_management_base_1.setLogger(logInst);
        const endProfile = logInst.profileOperation('ProjectApi.run');
        const project = await this.tryRead();
        const projectRunner = PluginFactory_1.default.getProjectRunnerFor(project.type);
        return projectRunner.run({ fs: this.fs(), project, options })
            .then((response) => {
            endProfile();
            return response;
        });
    }
    async buildManifest(context = { platform: PlatformContext_1.PLATFORM.CF }, logger = artifact_management_base_1.noopLogger) {
        const logInst = new artifact_management_base_1.ProjectAPILogger(logger.getChildLogger({ label: 'buildManifest' }));
        artifact_management_base_1.setLogger(logInst);
        const endProfile = logInst.profileOperation('ProjectApi.buildManifest');
        const project = await this.tryRead();
        const projectBuilder = BuildFactory_1.default.getBuilder(context, project, this.fs(), this.useHeadlessGenerator);
        return projectBuilder.generateManifest()
            .then(response => {
            endProfile();
            return response;
        });
    }
    async getManifest(logger = artifact_management_base_1.noopLogger) {
        const logInst = new artifact_management_base_1.ProjectAPILogger(logger.getChildLogger({ label: 'getManifest' }));
        artifact_management_base_1.setLogger(logInst);
        await this.buildManifest();
        const manifest = await this.fs().readYaml('mta.yaml');
        return manifest;
    }
    async build(context = { platform: PlatformContext_1.PLATFORM.CF }, logger = artifact_management_base_1.noopLogger) {
        const logInst = new artifact_management_base_1.ProjectAPILogger(logger.getChildLogger({ label: 'build' }));
        artifact_management_base_1.setLogger(logInst);
        const endProfile = logInst.profileOperation('ProjectApi.build');
        await artifact_management_base_1.Util.exec('rm', '-rf', `${this.fs().path('build/launchpad')}`);
        const project = await this.tryRead();
        const projectBuilder = BuildFactory_1.default.getBuilder(context, project, this.fs(), this.useHeadlessGenerator);
        return projectBuilder.build()
            .then(response => {
            endProfile();
            return response;
        });
    }
    async buildV2(context = { platform: PlatformContext_1.PLATFORM.CF }, logger = artifact_management_base_1.noopLogger) {
        const logInst = new artifact_management_base_1.ProjectAPILogger(logger.getChildLogger({ label: 'buildV2' }));
        artifact_management_base_1.setLogger(logInst);
        const endProfile = logInst.profileOperation('ProjectApi.buildV2');
        await artifact_management_base_1.Util.exec('rm', '-rf', `${this.fs().path('build/launchpad')}`);
        const project = await this.tryRead();
        await this.updateStatusTracker(project);
        const projectBuilder = BuildFactory_1.default.getBuilder(context, project, this.fs());
        return projectBuilder.buildV2()
            .then(response => {
            endProfile();
            return response;
        });
    }
    async updateStatusTracker(project) {
        const rootFs = this.fs();
        let statusTrackerContent = undefined;
        try {
            statusTrackerContent = await rootFs.readJson(statusTrackerFileName);
        }
        catch (error) {
            artifact_management_base_1.getLogger().error('Error reading .status_tracker file');
        }
        if (!statusTrackerContent) {
            const statusTrackerContent = {
                'db-deployer': false,
                'srv': false,
                'aux-ui-deployer': false,
                'launchpad': true,
            };
            await rootFs.writeJSON(statusTrackerFileName, statusTrackerContent);
            if (project) {
                const modules = project.modules;
                for (const module of modules) {
                    if (module.items && module.items.length > 0) {
                        const moduleTags = module.tags;
                        for (const tag of moduleTags) {
                            switch (tag) {
                                case 'app':
                                case 'ui5':
                                case 'mdk':
                                case 'taskui':
                                    statusTrackerContent['aux-ui-deployer'] = true;
                                    break;
                                case 'db':
                                    statusTrackerContent['db-deployer'] = true;
                                    break;
                                case 'srv':
                                    statusTrackerContent['srv'] = true;
                                    break;
                                default:
                                    break;
                            }
                        }
                    }
                }
                await rootFs.writeJSON(statusTrackerFileName, statusTrackerContent);
            }
        }
    }
    async deploy(logger = artifact_management_base_1.noopLogger) {
        this.invalidate_cachedLaunchURL();
        const logInst = new artifact_management_base_1.ProjectAPILogger(logger.getChildLogger({ label: 'deploy' }));
        artifact_management_base_1.setLogger(logInst);
        const endProfile = logInst.profileOperation('ProjectApi.deploy');
        const project = await this.tryRead();
        const context = { platform: PlatformContext_1.PLATFORM.CF };
        const projectBuilder = BuildFactory_1.default.getBuilder(context, project, this.fs());
        return projectBuilder.deploy()
            .then(async (response) => {
            await projectBuilder.updateDeployedTime();
            endProfile();
            return response;
        });
    }
    async deployV2(logger = artifact_management_base_1.noopLogger) {
        this.invalidate_cachedLaunchURL();
        const logInst = new artifact_management_base_1.ProjectAPILogger(logger.getChildLogger({ label: 'deployV2' }));
        artifact_management_base_1.setLogger(logInst);
        const endProfile = logInst.profileOperation('ProjectApi.deployV2');
        const project = await this.tryRead();
        const context = { platform: PlatformContext_1.PLATFORM.CF };
        const projectBuilder = BuildFactory_1.default.getBuilder(context, project, this.fs());
        return projectBuilder.deployV2()
            .then(async (response) => {
            await projectBuilder.updateDeployedTime();
            endProfile();
            return response;
        });
    }
    async getProjectInfo(logger = artifact_management_base_1.noopLogger) {
        const logInst = new artifact_management_base_1.ProjectAPILogger(logger.getChildLogger({ label: 'getProject' }));
        artifact_management_base_1.setLogger(logInst);
        const endProfile = logInst.profileOperation('ProjectApi.getProjectInfo');
        return this.projectInstance().getProjectInstance().then((response) => {
            this.path = this.projectInstance().getPath();
            endProfile();
            if (response && response.projectData) {
                return response.projectData;
            }
            return undefined;
        });
    }
    async getModulesInfo(logger = artifact_management_base_1.noopLogger) {
        const logInst = new artifact_management_base_1.ProjectAPILogger(logger.getChildLogger({ label: 'getModules' }));
        artifact_management_base_1.setLogger(logInst);
        const endProfile = logInst.profileOperation('ProjectApi.getModulesInfo');
        return this.projectInstance().readModules().then((response) => {
            this.path = this.projectInstance().getPath();
            endProfile();
            return response;
        });
    }
    /**
     * @deprecated Use getApplicationDeploymentSummary() instead
     */
    async getProjectOverviewURL(logger = artifact_management_base_1.noopLogger) {
        const logInst = new artifact_management_base_1.ProjectAPILogger(logger.getChildLogger({ label: 'getProjectOverviewURL' }));
        artifact_management_base_1.setLogger(logInst);
        const endProfile = logInst.profileOperation('ProjectApi.getProjectOverviewURL');
        const application_summary = await this.getApplicationDeploymentSummary();
        endProfile();
        return application_summary === null || application_summary === void 0 ? void 0 : application_summary.ProjectOverviewURL;
    }
    async getApplicationDeploymentSummary(logger = artifact_management_base_1.noopLogger) {
        const logInst = new artifact_management_base_1.ProjectAPILogger(logger.getChildLogger({ label: 'getApplicationDeploymentSummary' }));
        artifact_management_base_1.setLogger(logInst);
        const endProfile = logInst.profileOperation('ProjectApi.getApplicationDeploymentSummary');
        let application_summary = undefined;
        const projectInfo = await this.getProjectInfo();
        const rootFs = this.fs();
        /**
         * Read the file and get the url.
         * If read is unsuccessful, build the url from cf commands and write to the file.
         */
        try {
            application_summary = await rootFs.readJson(urlFileName);
        }
        catch (error) {
            logInst.info('Error reading .application_summary file');
        }
        if (!application_summary || !application_summary.ProjectOverviewURL) {
            const project = {
                ...projectInfo,
                modules: [],
            };
            const context = { platform: PlatformContext_1.PLATFORM.CF };
            const projectBuilder = BuildFactory_1.default.getBuilder(context, project, this.fs());
            application_summary = {
                ProjectOverviewURL: await projectBuilder.getProjectOverviewURL(),
                DeployedUTCTime: await projectBuilder.getDeployedTime(),
                ApplicationLogURL: await projectBuilder.getApplicationLogURL(),
            };
            if (application_summary === null || application_summary === void 0 ? void 0 : application_summary.ProjectOverviewURL) {
                await rootFs.writeJSON(urlFileName, application_summary);
            }
        }
        endProfile();
        return application_summary;
    }
    async invalidate_cachedLaunchURL() {
        if (await this.fs().fileExists(urlFileName)) {
            this.fs().writeTextFile(urlFileName, '');
        }
    }
    async getDataInfo(data, mainEntityName, logger = artifact_management_base_1.noopLogger) {
        const logInst = new artifact_management_base_1.ProjectAPILogger(logger.getChildLogger({ label: 'getDataInfo' }));
        artifact_management_base_1.setLogger(logInst);
        const endProfile = logInst.profileOperation('ProjectApi.getDataInfo');
        const dataFirstUtil = new DataFirstUtil_1.default(this);
        if (data instanceof Array) {
            dataFirstUtil.setMainEntity(data, mainEntityName);
            endProfile();
            return data;
        }
        else if (typeof data === 'string') {
            const fileTokens = (data || '').split('.');
            if (fileTokens.length > 1) {
                try {
                    const mode = fileTokens[fileTokens.length - 1].toUpperCase();
                    if (mode === 'CSV') {
                        const csvRet = await dataFirstUtil.parseCSVFile(data, true);
                        endProfile();
                        return csvRet;
                    }
                    else if (mode === 'XML') {
                        const xmlRet = await dataFirstUtil.parseXMLFile(data, true);
                        endProfile();
                        return xmlRet;
                    }
                }
                catch (error) {
                    throw new Error(`Faile to parse the file: ${data}`);
                }
            }
            throw new Error(`Unsupported file type: ${data}`);
        }
        throw new Error(`Unsupported data type: ${data}`);
    }
}
exports.default = ProjectImpl;
//# sourceMappingURL=ProjectImpl.js.map
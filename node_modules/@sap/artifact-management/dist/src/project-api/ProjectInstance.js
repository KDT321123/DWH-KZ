"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectInstance = void 0;
const artifact_management_base_1 = require("@sap/artifact-management-base");
const ProjectModulesInstance_1 = __importDefault(require("./ProjectModulesInstance"));
const ProjectEntityInstance_1 = __importDefault(require("./ProjectEntityInstance"));
const PluginFactory_1 = __importDefault(require("../definitions/PluginFactory"));
class ProjectInstance extends ProjectEntityInstance_1.default {
    constructor(watchManager, fs, readModuleAsProject) {
        super(watchManager, fs);
        this._type = 'ProjectInstance';
        this.readModuleAsProject = readModuleAsProject;
        this._readDeepInProgress = undefined;
        this._readItemsInProgress = undefined;
    }
    async getData() {
        return this.getDataCached({
            load: async () => this.loadData(),
            onDataChanged: () => this.unloadChildren(),
        });
    }
    async loadData() {
        artifact_management_base_1.getLogger().info('Cache miss for ProjectInstance.getData(). invoked loadData() - Reading Project Data again.');
        return this.loadByReaders(PluginFactory_1.default.getProjectReaders(this.readModuleAsProject));
    }
    async loadProjectInstance(projectData) {
        artifact_management_base_1.getLogger().info('Cache miss for ProjectInstance.loadProjectInstance(). Creating new instance of ProjectModulesInstance');
        if (projectData) {
            /**
             * The main idea is that the fs of the ProjectInstance, namely fs.rootPath should always point to the actual project dir.
             *
             * Initially instance of ProjectInstance is created with the input path given to the Api. This means, the basePath
             * and the rootPath will point of the instance will point to the input path.
             *
             * In case when the actual project is at root path, we need not create a new fs because
             * rootPath and base will be same and both will point to the actual project dir.
             *
             * In case when the actual project is not at root path, some readers such as CapModuleReader, which rely on
             * the rootPath of the fs to do some operations such as reading the package.json may face failure because
             * no such file is present at rootPath.
             * Hence, we need to change the fs for ProjectInstance to point to the path where the project was found
             * once the project data is available so that readers can use roothPath to read items from project folder.
             *
             * In this way, the fs.rootPath of ProjectInstance will always point to the path of actual project folder.
             */
            if (this.fs.basePath !== projectData.path) {
                this.fs = artifact_management_base_1.FileSystemFactory.getFileSystem(projectData.path);
            }
            return new ProjectModulesInstance_1.default(this.watchManager, this.fs, projectData, this.readModuleAsProject);
        }
        else {
            return undefined;
        }
    }
    async getProjectInstance() {
        artifact_management_base_1.getLogger().debug('Entering ProjectInstance.getProjectInstance() ');
        // Call getData() outside of getChildCache load method to ensure its updated and invalidate children in case of data change
        const projectData = await this.getData();
        return this.getChildCached({
            name: 'projectInstance',
            load: async () => this.loadProjectInstance(projectData),
        }).then(response => {
            artifact_management_base_1.getLogger().debug('Exiting ProjectInstance.getProjectInstance()');
            return response;
        });
    }
    async readDeep(tag) {
        artifact_management_base_1.getLogger().debug(`Entering ProjectInstance.readDeep() - tag - ${tag}`);
        /* istanbul ignore if */
        if (this._readDeepInProgress && !tag) {
            artifact_management_base_1.getLogger().debug('ReadDeep already in progress, returning cached promise ...');
            return this._readDeepInProgress;
        }
        const readInProgress = this.getProjectInstance()
            .then((instance) => {
            var _a;
            if (instance) {
                /* istanbul ignore if */
                if (tag) {
                    if ((_a = instance.projectData.tags) === null || _a === void 0 ? void 0 : _a.includes(tag)) {
                        return instance.readDeep();
                    }
                }
                else {
                    return instance.readDeep()
                        .then(response => {
                        artifact_management_base_1.getLogger().debug(`Exiting ProjectInstance.readDeep() - tag - ${tag}`);
                        this._readDeepInProgress = undefined;
                        return response;
                    }).catch(error => {
                        this._readDeepInProgress = undefined;
                        if (!instance.projectData.info) {
                            instance.projectData.info = {};
                        }
                        instance.projectData.info.set('errors', [{ description: error.message }]);
                        return Object.assign({}, instance.projectData, { modules: [] });
                    });
                }
            }
            else {
                this.invalidate();
                this.unloadChildren();
                this._readDeepInProgress = undefined;
                return undefined;
            }
        }).catch((error) => {
            this._readDeepInProgress = undefined;
            artifact_management_base_1.getLogger().error('Error occurred while read of project - ', error);
            return undefined;
        });
        if (tag === undefined) {
            //cache only read all items. If individual tags are being read, 
            //you can end up with a whole lot of combinations. No use caching such requests.
            this._readDeepInProgress = readInProgress;
        }
        return readInProgress;
    }
    async readItems(filter) {
        artifact_management_base_1.getLogger().debug(`Entering ProjectInstance.readItems() - tag - ${JSON.stringify(filter)}`);
        /* istanbul ignore if */
        if (this._readItemsInProgress && !filter) {
            artifact_management_base_1.getLogger().debug('Read Items already in progress, returning cached promise ...');
            return this._readItemsInProgress;
        }
        const readInProgress = this.getProjectInstance()
            .then((instance) => {
            if (instance)
                return instance.readItems(filter)
                    .then(response => {
                    artifact_management_base_1.getLogger().debug(`Exiting ProjectInstance.readItems() - tag - ${JSON.stringify(filter)}`);
                    this._readItemsInProgress = undefined;
                    return response;
                });
            else {
                this.invalidate();
                this.unloadChildren();
                this._readItemsInProgress = undefined;
                return [];
            }
        }).catch((error) => {
            this._readItemsInProgress = undefined;
            artifact_management_base_1.getLogger().error('Error occurred while readItems of project - ', error);
            return [];
        });
        if (filter === undefined) {
            //cache only read all items. If individual filter items are being read, 
            //you can end up with a whole lot of combinations. No use caching such requests.
            this._readItemsInProgress = readInProgress;
        }
        return readInProgress;
    }
    async readModules() {
        const projectInstance = await this.getProjectInstance();
        if (projectInstance)
            return projectInstance.getModules();
        else
            return [];
    }
    async detailInfo(type, ref, entityPath, options) {
        artifact_management_base_1.getLogger().debug(`Entering ProjectInstance.detailInfo() - type - ref - ${JSON.stringify(type + ref)}`);
        const instance = await this.getProjectInstance();
        if (instance)
            return instance.detailInfo(type, ref, entityPath, options)
                .then(response => {
                artifact_management_base_1.getLogger().debug(`Exiting ProjectInstance.detailInfo() - type - ref - ${JSON.stringify(type + ref)}`);
                return response;
            });
        else
            return;
    }
    getPath() {
        return this.fs.rootPath;
    }
}
exports.ProjectInstance = ProjectInstance;
//# sourceMappingURL=ProjectInstance.js.map
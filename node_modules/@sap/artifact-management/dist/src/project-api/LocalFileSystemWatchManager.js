"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const micromatch_1 = __importDefault(require("micromatch"));
const events_1 = require("events");
const artifact_management_base_1 = require("@sap/artifact-management-base");
const path_1 = __importDefault(require("path"));
const parse_gitignore_1 = __importDefault(require("parse-gitignore"));
const chokidar = require('chokidar');
const ignoreList = [
    '/node_modules/**/*',
    '/**/node_modules/**/*',
    '/dist/**/*',
    '/**/dist/**/*',
    '/tmp/**/*',
    '/**/tmp/**/*',
    '/build/**/*',
    '/dist-zip/**/*',
    '/**/dist-zip/**/*',
];
/**
 */
class LocalFileSystemWatchManager extends events_1.EventEmitter {
    constructor(rootPath) {
        super();
        this.rootPath = rootPath;
        this.observers = new Map();
        this.filePatterns = [];
        this.eventTypes = [];
    }
    removeFileSystemWatcher(observersToDel) {
        for (const observer of observersToDel) {
            /* istanbul ignore if */
            if (!this.observers.has(observer.basePath)) {
                continue;
            }
            else {
                const observerList = this.observers.get(observer.basePath);
                for (let x = observerList.length - 1; x >= 0; x--) {
                    /* istanbul ignore else */
                    if (observerList[x].listener === observer.listener && observerList[x].globPattern === observer.globPattern) {
                        artifact_management_base_1.getLogger().debug(`removeFileSystemWatcher: ${observerList[x].globPattern}`);
                        observerList.splice(x, 1);
                    }
                }
            }
        }
    }
    createFileSystemWatcher(fs, globPatterns, listener) {
        artifact_management_base_1.getLogger().debug(`createFileSystemWatcher: ${globPatterns}`);
        const observers = [];
        for (const globPattern of globPatterns) {
            observers.push(this.addObserver(fs, globPattern, listener));
        }
        return observers;
    }
    createObserver(fs, globPattern, listener) {
        const patternPathRelativeToRoot = path_1.default.relative(this.rootPath, fs.path(globPattern));
        const matchParts = micromatch_1.default.scan(patternPathRelativeToRoot);
        return {
            fs: fs,
            basePath: matchParts.base,
            pathRelativeToRoot: patternPathRelativeToRoot,
            glob: matchParts.glob,
            isGlob: matchParts.isGlob,
            globPattern: globPattern,
            listener: listener,
        };
    }
    addObserver(fs, globPattern, listener) {
        var _a;
        const observer = this.createObserver(fs, globPattern, listener);
        let observerList;
        artifact_management_base_1.getLogger().debug(`BasePath ${observer.basePath} -- ${(_a = this.observers.get(observer.basePath)) === null || _a === void 0 ? void 0 : _a.length}`);
        if (this.observers.has(observer.basePath)) {
            observerList = this.observers.get(observer.basePath);
        }
        else {
            observerList = [];
            this.observers.set(observer.basePath, observerList);
        }
        observerList.push(observer);
        return observer;
    }
    //Method used only for debug purposes. (Not used in Prod code anywhere.)
    logObservers() {
        var _a, _b;
        let noOfListeners = 0;
        for (const key of this.observers.keys()) {
            noOfListeners += (_a = this.observers.get(key)) === null || _a === void 0 ? void 0 : _a.length;
            //getLogger().debug(`For Key - ${key} - Registered Listener - ${this.observers.get(key)?.length}`);
            (_b = this.observers.get(key)) === null || _b === void 0 ? void 0 : _b.forEach((observer, idx) => {
                artifact_management_base_1.getLogger().debug(`observer - ${observer.pathRelativeToRoot}`);
            });
        }
        artifact_management_base_1.getLogger().debug(`Total Number of listeners ---> ${noOfListeners}`);
    }
    destroy() {
    }
    async enable() {
        /* istanbul ignore if */
        if (this.watcher)
            return;
        const fs = artifact_management_base_1.FileSystemFactory.getFileSystem(this.rootPath);
        let filePathsNotToWatch = [];
        /* istanbul ignore if */
        if (await fs.fileExists('.gitignore')) {
            const gitIgnoreText = await fs.readTextFile('.gitignore');
            filePathsNotToWatch = parse_gitignore_1.default(gitIgnoreText).map(path => this.rootPath + '/' + path);
        }
        for (const pattern of ignoreList) {
            /* istanbul ignore else */
            if (!filePathsNotToWatch.includes(this.rootPath + pattern)) {
                filePathsNotToWatch.push(this.rootPath + pattern);
            }
        }
        this.watcher = chokidar.watch(this.rootPath, { ignoreInitial: true, ignored: filePathsNotToWatch }).on('all', (event, filename) => {
            this.watchEvent(event, filename);
        });
    }
    disable() {
        /* istanbul ignore if */
        if (!this.watcher)
            return;
        this.watcher.close();
        this.watcher = undefined;
    }
    /* istanbul ignore next */
    async watchEvent(event, filename) {
        artifact_management_base_1.getLogger().info(`Change in file detected event - ${event}, filename - ${filename}`);
        const filePathPattern = path_1.default.relative(this.rootPath, filename);
        let filePath = filePathPattern;
        let index = 0;
        let matchFound = false;
        let fileIsAtRootFolder = false;
        if (filePath.indexOf('/') === -1) {
            fileIsAtRootFolder = true;
        }
        const OBSERVERS_FOR_ROOT = '';
        while (index !== -1) {
            if (this.observers.has(filePath) || fileIsAtRootFolder) {
                let observerList = this.observers.get(filePath) || [];
                if (fileIsAtRootFolder) {
                    observerList = observerList.concat(this.observers.get(OBSERVERS_FOR_ROOT) || []);
                    //If a new folder gets added then pattern matchers will be '' (empty) path in map. 
                    //Ex., folderMatchPatterns registered by ProjectModule instance like '*' , 'app/*' will have root path of empty.
                    //So if a new module like workflow-content is created path relative to root will come as just 'workflow-content'.
                }
                for (const observer of observerList) {
                    if (micromatch_1.default([filePathPattern], observer.pathRelativeToRoot).length === 1) {
                        artifact_management_base_1.getLogger().debug(`File match found  ${filePathPattern} - ${observer.pathRelativeToRoot}`);
                        observer.listener(event, filePathPattern);
                        matchFound = true;
                    }
                }
                break;
            }
            index = filePath.lastIndexOf('/');
            filePath = filePath.substring(0, index);
        }
        if (matchFound) {
            //No need to check for 'ADD' Event specifically because there are appropriate folder level watchers
            //at project level (projectmoduleinstance) & module level (moduleinstance)
            //TODO: Need to exclude watching /app/{Mdk-app}/Services/.{service}.xml files.
            //These xml files are updated by MDKServiceBuild tasks whenever there is a change detected in CAP Service.
            this.eventTypes.push(event);
            this.filePatterns.push(filePathPattern);
            if (this.eventInQueue === undefined) {
                this.eventInQueue = setTimeout(() => {
                    artifact_management_base_1.getLogger().debug(`Debouncing and emitting the file event - No of events queued: ${this.eventTypes.length}`);
                    this.emit('change', this.eventTypes, this.filePatterns);
                    this.eventTypes.splice(0, this.eventTypes.length);
                    this.filePatterns.splice(0, this.filePatterns.length);
                    clearTimeout(this.eventInQueue); //unnecessary, but doing it as a normal cleanup.
                    this.eventInQueue = undefined;
                }, 300);
                //Debouncing is done because the moment watchers get events the first thing they do is call read API.
                //So read API gets bombarded. Debouncing spaces the events that are emitted without loosing any of the events.
            }
        }
    }
}
exports.default = LocalFileSystemWatchManager;
//# sourceMappingURL=LocalFileSystemWatchManager.js.map
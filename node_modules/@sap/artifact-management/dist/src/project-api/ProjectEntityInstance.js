"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const artifact_management_base_1 = require("@sap/artifact-management-base");
const events_1 = require("events");
const lodash_1 = __importDefault(require("lodash"));
const statusTrackerFileName = '.status_tracker';
class ProjectEntityInstance extends events_1.EventEmitter {
    constructor(watchManager, fs) {
        super();
        this.watchManager = watchManager;
        this.fs = fs;
        this.loaded = false;
        this.children = {};
        this.observers = [];
        this.staleData = false;
        this.tags = [];
    }
    /**
     * Get child data of an entity
     *
     * The "load" function is called to receive the data. The resulting data will be cached.
     * As there can be multiple children, they need to be distinguished by "name" which is used as cache key.
     *
     * Call "unloadChildren()" to clear the cache. The method "load" will be called again with the next call
     * of "getChildCache()".
     *
     */
    async getChildCached({ name, load }) {
        if (!this.children[name]) {
            this.unloadChildren();
            artifact_management_base_1.getLogger().debug(`Cache miss for child ${name}. Invoking Load.()`);
            const result = await load();
            this.children[name] = result;
        }
        return this.children[name];
    }
    /**
     * Get data of an entity
     *
     * The "load" function is called to receive the data. The resulting data will be cached.
     *
     * The "onDataChanged" function is called when the data is changed compared to a previous call. It can
     * be used to invalidate depending data, e.g. children by calling "unloadChildren()".
     *
     * Call "unloadData()" to clear the cache. The method "load" will be called again with the next call
     * of "getDataCached()"
     *
     * An instance must have only one method where "getDataCached()" is called otherwise a call will
     * return the previously cached value of a different one.
     *
     */
    async getDataCached({ load, onDataChanged }) {
        if (!this.loaded || this.staleData) {
            //If entity's data is loaded its considered as valid until its flagged stale via filewatch manager
            //so even if data is undefined, if u read again it will still be undefined unless its gone stale.
            const oldData = this.data;
            const entity = `${this._type} - path ${this.fs.basePath} - Loaded : ${this.loaded} -- Stale: ${this.staleData}`;
            artifact_management_base_1.getLogger().debug(`Fetching data  for - ${entity}`);
            this.unload();
            const result = await load();
            if (result) {
                this.data = result.data;
                this.loaded = true;
                if (this.observers.length === 0) {
                    //There is a watcher already registered. So dont register.
                    this.registerWatchPatterns(result.watchPatterns);
                    artifact_management_base_1.getLogger().debug(`Registered watch pattern - ${result.watchPatterns}`);
                }
            }
            else {
                artifact_management_base_1.getLogger().debug(`Data undefined for - ${entity}`);
            }
            this.staleData = false;
            if (onDataChanged) {
                if (!lodash_1.default.isEqual(this.data, oldData)) {
                    artifact_management_base_1.getLogger().info(`-# Data has changed for - ${entity}. Invoking onDataChangedCallBack`);
                    onDataChanged(this.data, oldData);
                }
                else {
                    artifact_management_base_1.getLogger().info(`-> Data hasnt changed for - ${entity}. callback not being invoked`);
                }
            }
        }
        return lodash_1.default.cloneDeep(this.data);
    }
    async registerWatchPatterns(patterns, callback) {
        const observers = this.watchManager.createFileSystemWatcher(this.fs, patterns, (callback !== undefined ? callback : (event, path) => {
            this.invalidate();
            this.flagModuleDirty(path);
        }));
        this.observers.push(...observers);
    }
    async flagModuleDirty(path) {
        let statusTrackerContent = undefined;
        const rootFs = artifact_management_base_1.FileSystemFactory.getFileSystem(this.fs.rootPath);
        try {
            statusTrackerContent = await rootFs.readJson(statusTrackerFileName);
        }
        catch (error) {
            artifact_management_base_1.getLogger().error('Error reading .status_tracker file');
        }
        const isCSVFile = path.match(/\.csv$/) ? true : false;
        if (statusTrackerContent) {
            if (this.tags) {
                for (const tag of this.tags) {
                    switch (tag) {
                        case 'app':
                        case 'ui5':
                        case 'mdk':
                        case 'taskui':
                            statusTrackerContent['aux-ui-deployer'] = true;
                            statusTrackerContent['launchpad'] = true;
                            break;
                        case 'db':
                            statusTrackerContent['db-deployer'] = true;
                            if (!isCSVFile) {
                                statusTrackerContent['launchpad'] = true;
                            }
                            break;
                        case 'srv':
                            statusTrackerContent['srv'] = true;
                            statusTrackerContent['launchpad'] = true;
                            break;
                        default:
                            break;
                    }
                }
                await rootFs.writeJSON(statusTrackerFileName, statusTrackerContent);
            }
        }
    }
    unRegisterWatchPatterns() {
        this.watchManager.removeFileSystemWatcher(this.observers);
    }
    async loadByReader(reader) {
        const watchPatterns = [];
        const matchConditions = reader.matchConditions;
        const matchedFiles = {};
        let matchType;
        if (matchConditions.requiredFilePatterns) {
            watchPatterns.push(...matchConditions.requiredFilePatterns);
            let includedPatternsMatchCount = 0;
            await Promise.all(matchConditions.requiredFilePatterns.map(async (pattern) => {
                const result = await this.fs.glob(pattern, { onlyFiles: true });
                if (result.length > 0) {
                    includedPatternsMatchCount++;
                    matchedFiles[pattern] = result;
                }
            }));
            // Check if at least one file per pattern found
            if (includedPatternsMatchCount !== matchConditions.requiredFilePatterns.length)
                return;
            if (matchConditions.rule) {
                matchType = 'required';
                if (!await matchConditions.rule({ matchType, fs: this.fs })) {
                    return;
                }
            }
        }
        /* istanbul ignore if */
        if (matchConditions.mustNotExistFilePatterns) {
            watchPatterns.push(...matchConditions.mustNotExistFilePatterns);
            let excludedPatternsMatchCount = 0;
            await Promise.all(matchConditions.mustNotExistFilePatterns.map(async (pattern) => {
                const result = await this.fs.glob(pattern, { onlyFiles: true });
                if (result.length > 0) {
                    excludedPatternsMatchCount++;
                    matchedFiles[pattern] = result;
                }
            }));
            // Check if no file found
            if (excludedPatternsMatchCount > 0)
                return;
            if (matchConditions.rule) {
                matchType = 'mustNotExist';
                if (!matchConditions.rule({ matchType, fs: this.fs })) {
                    return;
                }
            }
        }
        /* istanbul ignore if */
        if (matchConditions.filePatterns) {
            await Promise.all(matchConditions.filePatterns.map(async (pattern) => {
                const result = await this.fs.glob(pattern, { onlyFiles: true });
                if (result.length > 0) {
                    matchedFiles[pattern] = result;
                }
            }));
        }
        const data = await reader.read({ fs: this.fs, matchedFiles });
        if (typeof data !== 'undefined') {
            /* istanbul ignore if */
            if (matchConditions.filePatterns) {
                watchPatterns.push(...matchConditions.filePatterns);
            }
            /* istanbul ignore if */
            if (matchConditions.dependentPatterns) {
                watchPatterns.push(...matchConditions.dependentPatterns);
            }
        }
        artifact_management_base_1.getLogger().debug(`WatchPatterns - ${JSON.stringify(watchPatterns)}, files - ${JSON.stringify(matchedFiles)}`);
        return { data, watchPatterns };
    }
    async loadByReaders(readers) {
        let watchPatterns = [];
        let data = undefined;
        let itemFound = false;
        for (const reader of readers) {
            try {
                const result = await this.loadByReader(reader) || { watchPatterns: [], data: undefined };
                data = result.data;
                watchPatterns = watchPatterns.concat(result.watchPatterns);
                if (typeof result.data !== 'undefined') {
                    itemFound = true;
                    break;
                }
            }
            catch (error) {
                artifact_management_base_1.getLogger().error(`Exception when trying to read dir "${this.fs.path()}" with reader "${reader}"`, error);
            }
        }
        if (itemFound) {
            return { data, watchPatterns };
        }
        // If project is not found and readers contain an instance of project reader,
        // we navigate to sub-folders one by one and try to find project data.
        const hasProjectReader = readers.some((reader) => reader instanceof artifact_management_base_1.ProjectReader);
        if (hasProjectReader) {
            const folders = await this.fs.glob('*', { ignore: ['**/node_modules'], onlyDirectories: true });
            for (const folder of folders) {
                this.fs = this.fs.navigate(folder);
                const result = await this.loadByReaders(readers);
                if (result !== undefined && result.data !== undefined) {
                    this.fs = this.fs.navigate('../');
                    return result;
                }
            }
            this.fs = this.fs.navigate('../');
            return { watchPatterns: [], data: undefined };
        }
    }
    async invalidate() {
        this.staleData = true;
        //just flag data as stale, dont clear the data.
        //during getDataCached, olddata needs to be compared with new fetched data.
    }
    unload() {
        artifact_management_base_1.getLogger().debug(`Unloading data  for base path- ${this.fs.basePath} - type - ${this._type}`);
        this.loaded = false;
        this.data = undefined;
        //Here when unloading an entity, were are just unloading that entity & not its children.
        //Because when loadData of entity is again called if data has changed then `onDataChanged` event unloadsChildren.
    }
    destroy() {
        this.unload();
        this.unloadChildren();
        this.unRegisterWatchPatterns();
        this.emit('entityDestroyed', { entityType: this._type, entity: this });
    }
    unloadChildren() {
        for (const name in this.children || {}) {
            artifact_management_base_1.getLogger().debug(`Unloading children data for name: ${name} - ${this.fs.basePath}`);
            const child = this.children[name];
            /* istanbul ignore if */
            if (Array.isArray(child)) {
                for (const item of child) {
                    item.destroy && item.destroy();
                }
            }
            else if (child && child.destroy) {
                child.destroy();
            }
        }
        this.children = {};
    }
}
exports.default = ProjectEntityInstance;
//# sourceMappingURL=ProjectEntityInstance.js.map
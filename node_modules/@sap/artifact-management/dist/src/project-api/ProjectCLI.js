#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cli = void 0;
const ProjectImpl_1 = __importDefault(require("./ProjectImpl"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const yargs_1 = __importDefault(require("yargs"));
const CallDeferred_1 = __importDefault(require("../commons/CallDeferred"));
const artifact_management_base_1 = require("@sap/artifact-management-base");
async function cli() {
    yargs_1.default
        .scriptName('dev-project')
        .usage('$0 <cmd> [path] [types..]')
        .command('list-items [path] [types..]', 'Show project items', (yargs) => {
        yargs.positional('debug', {
            type: 'boolean',
            default: false,
            describe: 'enable logging',
        });
        yargs.positional('loglevel', {
            type: 'string',
            default: undefined,
            describe: 'can specify log level "off" | "fatal" | "error" | "warn" | "info" | "debug" | "silly"',
        });
    }, async (argv) => {
        if (!configureLogger(argv)) {
            return;
        }
        artifact_management_base_1.getLogger().info('Reading entities...');
        const projectPath = argv.path || '.';
        const types = argv.types;
        const filter = (types === null || types === void 0 ? void 0 : types.length) ? { types } : undefined;
        const api = new ProjectImpl_1.default(projectPath);
        const entities = await api.readItems(filter);
        console.log(JSON.stringify(entities, null, 2));
    })
        .command('get-detail-info [path] [type] [ref] [entityPath]', 'Show detail information based on type and ref provided', (yargs) => {
        yargs.positional('debug', {
            type: 'boolean',
            default: false,
            describe: 'enable logging',
        });
        yargs.positional('loglevel', {
            type: 'string',
            default: undefined,
            describe: 'can specify log level "off" | "fatal" | "error" | "warn" | "info" | "debug" | "silly"',
        });
        yargs.positional('inherited', {
            type: 'boolean',
            default: undefined,
            describe: 'include the inherited properties for CDSEntity',
        });
    }, async (argv) => {
        if (!configureLogger(argv)) {
            return;
        }
        artifact_management_base_1.getLogger().info('Getting detailed info of entities...');
        const projectPath = argv.path || '.';
        const type = argv.type;
        const ref = argv.ref;
        const entityPath = argv.entityPath;
        let options = undefined;
        if (argv.inherited !== undefined) {
            options = {
                inherited: argv.inherited,
            };
        }
        if (type && ref) {
            const api = new ProjectImpl_1.default(projectPath);
            const entities = await api.getDetailInfo(type, ref, entityPath, options);
            console.log(JSON.stringify(entities, null, 2));
        }
        else {
            console.log('Invalid arguments length. Valid format is "dev-project get-detail-info [path] [type] [ref] [entitypath]"');
        }
    })
        .command('show [path]', 'Show project structure', (yargs) => {
        yargs.positional('debug', {
            type: 'boolean',
            default: false,
            describe: 'enable logging',
        });
        yargs.positional('loglevel', {
            type: 'string',
            default: undefined,
            describe: 'can specify log level "off" | "fatal" | "error" | "warn" | "info" | "debug" | "silly"',
        });
    }, async (argv) => {
        if (!configureLogger(argv)) {
            return;
        }
        const projectPath = argv.path || '.';
        const api = new ProjectImpl_1.default(projectPath);
        const project = await api.read();
        console.log(JSON.stringify(project, undefined, 2));
    })
        .command('show-manifest [path]', 'Show project manifest', (yargs) => {
        yargs.positional('debug', {
            type: 'boolean',
            default: false,
            describe: 'enable logging',
        });
        yargs.positional('loglevel', {
            type: 'string',
            default: undefined,
            describe: 'can specify log level "off" | "fatal" | "error" | "warn" | "info" | "debug" | "silly"',
        });
    }, async (argv) => {
        if (!configureLogger(argv)) {
            return;
        }
        artifact_management_base_1.getLogger().info('Gathering project info...');
        const projectPath = argv.path || '.';
        const api = new ProjectImpl_1.default(projectPath);
        const mtaObject = await api.getManifest();
        console.log(js_yaml_1.default.dump(mtaObject));
    })
        .command('build [path] [useHeadlessGenerator]', 'Generate an mta.yaml file and build an mtar file', (yargs) => {
        yargs.positional('debug', {
            type: 'boolean',
            default: false,
            describe: 'enable logging',
        });
        yargs.positional('loglevel', {
            type: 'string',
            default: undefined,
            describe: 'can specify log level "off" | "fatal" | "error" | "warn" | "info" | "debug" | "silly"',
        });
    }, async (argv) => {
        if (!configureLogger(argv)) {
            return;
        }
        const projectPath = argv.path || '.';
        const useHeadlessGenerator = argv.useHeadlessGenerator;
        if (useHeadlessGenerator && useHeadlessGenerator === 'true') {
            const api = new ProjectImpl_1.default(projectPath, false, !!useHeadlessGenerator);
            await api.build();
        }
        else {
            const api = new ProjectImpl_1.default(projectPath);
            await api.build();
        }
    })
        .command('buildV2 [path]', 'Generate an mta.yaml, generate zips and mtad.yaml file', (yargs) => {
        yargs.positional('debug', {
            type: 'boolean',
            default: false,
            describe: 'enable logging',
        });
        yargs.positional('loglevel', {
            type: 'string',
            default: undefined,
            describe: 'can specify log level "off" | "fatal" | "error" | "warn" | "info" | "debug" | "silly"',
        });
    }, async (argv) => {
        if (!configureLogger(argv)) {
            return;
        }
        const projectPath = argv.path || '.';
        const api = new ProjectImpl_1.default(projectPath);
        await api.buildV2();
    })
        .command('deploy [path] [useHeadlessGenerator]', 'Generate an mta.yaml file, build mtar file and deploy it', (yargs) => {
        yargs.positional('debug', {
            type: 'boolean',
            default: false,
            describe: 'enable logging',
        });
        yargs.positional('loglevel', {
            type: 'string',
            default: undefined,
            describe: 'can specify log level "off" | "fatal" | "error" | "warn" | "info" | "debug" | "silly"',
        });
    }, async (argv) => {
        if (!configureLogger(argv)) {
            return;
        }
        const projectPath = argv.path || '.';
        let api = new ProjectImpl_1.default(projectPath);
        const useHeadlessGenerator = argv.useHeadlessGenerator;
        if (useHeadlessGenerator === 'true') {
            api = new ProjectImpl_1.default(projectPath, false, !!useHeadlessGenerator);
        }
        await api.build();
        await api.deploy();
        const projectOverviewURL = await api.getProjectOverviewURL();
        console.log({ 'applicationOverviewURL': projectOverviewURL });
    })
        .command('deployV2 [path]', 'Generate mta.yaml, generate zips and mtad.yaml file, generate mtar file and deploy it', (yargs) => {
        yargs.positional('debug', {
            type: 'boolean',
            default: false,
            describe: 'enable logging',
        });
        yargs.positional('loglevel', {
            type: 'string',
            default: undefined,
            describe: 'can specify log level "off" | "fatal" | "error" | "warn" | "info" | "debug" | "silly"',
        });
    }, async (argv) => {
        if (!configureLogger(argv)) {
            return;
        }
        const projectPath = argv.path || '.';
        const api = new ProjectImpl_1.default(projectPath);
        await api.buildV2();
        await api.deployV2();
        const projectOverviewURL = await api.getProjectOverviewURL();
        console.log({ 'applicationOverviewURL': projectOverviewURL });
    })
        .command('get-projectoverview-url [path]', 'get project overview url of deployed application', (yargs) => {
        yargs.positional('debug', {
            type: 'boolean',
            default: false,
            describe: 'enable logging',
        });
        yargs.positional('loglevel', {
            type: 'string',
            default: undefined,
            describe: 'can specify log level "off" | "fatal" | "error" | "warn" | "info" | "debug" | "silly"',
        });
    }, async (argv) => {
        if (!configureLogger(argv)) {
            return;
        }
        const projectPath = argv.path || '.';
        const api = new ProjectImpl_1.default(projectPath);
        try {
            const projectOverviewURL = await api.getProjectOverviewURL();
            console.log({ 'applicationOverviewURL': projectOverviewURL });
        }
        catch (error) {
            console.log({ 'errorCode': 1, 'errorMessage': error.message });
        }
    })
        .command('get-application-deployment-summary [path]', 'get project summary url of deployed application', (yargs) => {
        yargs.positional('debug', {
            type: 'boolean',
            default: false,
            describe: 'enable logging',
        });
        yargs.positional('loglevel', {
            type: 'string',
            default: undefined,
            describe: 'can specify log level "off" | "fatal" | "error" | "warn" | "info" | "debug" | "silly"',
        });
    }, async (argv) => {
        if (!configureLogger(argv)) {
            return;
        }
        const projectPath = argv.path || '.';
        const api = new ProjectImpl_1.default(projectPath);
        try {
            const application_summary = await api.getApplicationDeploymentSummary();
            console.log({ 'applicationSummary': application_summary });
        }
        catch (error) {
            console.log({ 'errorCode': 1, 'errorMessage': error.message });
        }
    })
        .command('run [path] [options..]', 'Run application locally. Currently, supported options are port <number> and open', (yargs) => {
        yargs.positional('debug', {
            type: 'boolean',
            default: false,
            describe: 'enable logging',
        });
        yargs.positional('loglevel', {
            type: 'string',
            default: undefined,
            describe: 'can specify log level "off" | "fatal" | "error" | "warn" | "info" | "debug" | "silly"',
        });
        yargs.positional('launchpad', {
            type: 'boolean',
            default: undefined,
            describe: 'only generate LCAP launchpad but not run CDS server',
        });
    }, async (argv) => {
        if (!configureLogger(argv)) {
            return;
        }
        const projectPath = argv.path || '.';
        let option = argv.options || undefined;
        if (argv.launchpad) {
            option = (option || []).concat('launchpad');
        }
        const api = new ProjectImpl_1.default(projectPath);
        await api.run(option);
    })
        .command('watch [path]', 'Auto build', (yargs) => {
        yargs.positional('debug', {
            type: 'boolean',
            default: false,
            describe: 'enable logging',
        });
        yargs.positional('loglevel', {
            type: 'string',
            default: undefined,
            describe: 'can specify log level "off" | "fatal" | "error" | "warn" | "info" | "debug" | "silly"',
        });
    }, async (argv) => {
        if (!configureLogger(argv)) {
            return;
        }
        const projectPath = argv.path || '.';
        const api = new ProjectImpl_1.default(projectPath);
        const autoBuilder = await api.autoBuild();
        await autoBuilder.start();
    })
        .command('watch-items [path]', 'Watch for item changes', (yargs) => {
        yargs.positional('debug', {
            type: 'boolean',
            default: false,
            describe: 'enable logging',
        });
        yargs.positional('loglevel', {
            type: 'string',
            default: undefined,
            describe: 'can specify log level "off" | "fatal" | "error" | "warn" | "info" | "debug" | "silly"',
        });
    }, async (argv) => {
        if (!configureLogger(argv)) {
            return;
        }
        const projectPath = argv.path || '.';
        const api = new ProjectImpl_1.default(projectPath);
        const itemWatcher = await api.watchItems();
        const printItems = async (event, file) => {
            let i = 0;
            for (; event && i < event.length; i++) {
                artifact_management_base_1.getLogger().info(`Recieved Event -> ${event[i]} : File - ${file[i]}`);
            }
            artifact_management_base_1.getLogger().info(`One Read Items being fired for  ${i} :events`);
            const items = await itemWatcher.readItems();
            artifact_management_base_1.getLogger().info(`Event Type -> ${event} : File - ${file}`);
            artifact_management_base_1.getLogger().debug(JSON.stringify(items, null, 2));
        };
        const deferredCall = new CallDeferred_1.default({
            func: printItems,
            triggerDelay: 20,
            maxTriggerDelay: 1000,
            recallDelay: 2000,
        });
        itemWatcher.on('updated', (event, file) => printItems(event, file));
        deferredCall.call();
    })
        .command('get-project-info [path]', 'show project info', (yargs) => {
        yargs.positional('debug', {
            type: 'boolean',
            default: false,
            describe: 'enable logging',
        });
        yargs.positional('loglevel', {
            type: 'string',
            default: undefined,
            describe: 'can specify log level "off" | "fatal" | "error" | "warn" | "info" | "debug" | "silly"',
        });
    }, async (argv) => {
        if (!configureLogger(argv)) {
            return;
        }
        const projectPath = argv.path || '.';
        const api = new ProjectImpl_1.default(projectPath);
        const projectInfo = await api.getProjectInfo();
        console.log(JSON.stringify(projectInfo, undefined, 2));
    })
        .command('get-modules-info [path]', 'show modules info', (yargs) => {
        yargs.positional('debug', {
            type: 'boolean',
            default: false,
            describe: 'enable logging',
        });
        yargs.positional('loglevel', {
            type: 'string',
            default: undefined,
            describe: 'can specify log level "off" | "fatal" | "error" | "warn" | "info" | "debug" | "silly"',
        });
    }, async (argv) => {
        if (!configureLogger(argv)) {
            return;
        }
        const projectPath = argv.path || '.';
        const api = new ProjectImpl_1.default(projectPath);
        const modulesInfo = await api.getModulesInfo();
        console.log(JSON.stringify(modulesInfo, undefined, 2));
    })
        .command('get-data-info [filePath]', 'read and parse a data file', (yargs) => {
        yargs.positional('debug', {
            type: 'boolean',
            default: false,
            describe: 'enable logging',
        });
        yargs.positional('loglevel', {
            type: 'string',
            default: undefined,
            describe: 'can specify log level "off" | "fatal" | "error" | "warn" | "info" | "debug" | "silly"',
        });
    }, async (argv) => {
        if (!configureLogger(argv)) {
            return;
        }
        const filePath = argv.filePath || '.';
        const api = new ProjectImpl_1.default('.');
        const data = await api.getDataInfo(filePath);
        console.log(JSON.stringify(data, undefined, 2));
    })
        .help()
        .strict()
        .demandCommand()
        .argv;
}
exports.cli = cli;
function configureLogger(argv) {
    let logLevel = argv.loglevel;
    if (logLevel) {
        if (!isLogLevelValid(logLevel)) {
            console.error('Invalid log level input. Possible values - silly|debug|info|warn|error ');
            return false;
        }
    }
    else {
        logLevel = 'info';
    }
    //If user specifies --debug then log stmts are printed on console. 
    if (argv.debug) {
        artifact_management_base_1.ProjectAPILogger.enableConsoleAndFileLogging(logLevel, true);
    }
    else {
        //default all logs goes into just log file, even if he doesnt specify --debug on cmd line.
        artifact_management_base_1.ProjectAPILogger.enableConsoleAndFileLogging(logLevel);
    }
    return true;
}
function isLogLevelValid(logLevel) {
    const regexp = /silly|debug|info|warn|error/;
    return regexp.test(logLevel);
}
cli();
//# sourceMappingURL=ProjectCLI.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const artifact_management_base_1 = require("@sap/artifact-management-base");
const MtaBuilder_1 = __importDefault(require("../mta-generator/MtaBuilder"));
const PluginFactory_1 = __importDefault(require("../definitions/PluginFactory"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const _ = require("lodash");
const path_1 = require("path");
const XsSecurityModuleManifestGenerator_1 = __importDefault(require("../plugins/xsuaa/generators/XsSecurityModuleManifestGenerator"));
const OverviewPageGenerator_1 = __importDefault(require("./OverviewPageGenerator"));
const UI5ModuleGenerator_1 = __importDefault(require("../plugins/ui5/generators/UI5ModuleGenerator"));
const artifact_management_mdkplugin_1 = require("@sap/artifact-management-mdkplugin");
const CapLaunchpadGenerator_1 = __importDefault(require("../plugins/cap/generators/CapLaunchpadGenerator"));
const path_2 = __importDefault(require("path"));
const MtaMerger_1 = __importDefault(require("../mta-generator/MtaMerger"));
class CFProjectBuilder {
    constructor(project, fs, useHeadlessGenerator) {
        this.resources = [];
        this.requiredServices = new Set();
        this.moduleContext = [];
        this.moduleCommandMap = new Map();
        this.project = project;
        this.fs = fs;
        this.useHeadlessGenerator = useHeadlessGenerator ? true : false;
        this.buildFs = fs.navigate('build');
        this.nameFactory = artifact_management_base_1.NameFactory.getInstance(`${this.project.prefix}-`);
        this.projectGeneratorContext = new artifact_management_base_1.ModuleGeneratorContext(this.project, this.fs, this.nameFactory);
    }
    async build() {
        await this.buildFs.mkdir('.', { recursive: true });
        await this.generateManifest();
        await this.buildMtar();
    }
    async isApplicationSummaryFilePresent() {
        const isFilePresent = await this.fs.fileExists('.application_summary');
        return isFilePresent;
    }
    async buildV2() {
        await this.buildFs.mkdir('.', { recursive: true });
        await this.generateManifest(true);
        if (!await this.isApplicationSummaryFilePresent()) {
            await this.buildMtar();
        }
        else {
            const modulesToBuild = await this.readStatusTracker();
            if (modulesToBuild.length > 0) {
                await this.executePreBuildCommands(modulesToBuild);
                const moduleNamesToBuild = this.generateModuleNamesToDeploy(modulesToBuild, ',');
                await this.buildMtad(moduleNamesToBuild);
            }
        }
    }
    async executePreBuildCommands(modulesToBuild) {
        let modulesPathAndCommands = [];
        const beforeAllContents = this.moduleCommandMap.get('before-all');
        if (beforeAllContents) {
            modulesPathAndCommands = modulesPathAndCommands.concat(beforeAllContents);
        }
        for (const moduleToBuild of modulesToBuild) {
            const modulesMap = this.moduleCommandMap.get(moduleToBuild);
            if (modulesMap) {
                modulesPathAndCommands = modulesPathAndCommands.concat(modulesMap);
            }
        }
        /**
         * Pre-build commands associated with launchpad will be executed only when there is changes in db(non-csv file related changes),
         * srv, mdk or ui modules.
         */
        if (modulesPathAndCommands.length > 0) {
            for (const modulePathAndCommand of modulesPathAndCommands) {
                const path = modulePathAndCommand.path.length > 0 ? modulePathAndCommand.path : '';
                for (const command of modulePathAndCommand.commands) {
                    await artifact_management_base_1.Util.execute(command, path_2.default.join(this.fs.rootPath, path));
                }
            }
        }
    }
    generateModuleNamesToDeploy(modulesToBuild, separator) {
        /**
         * Adds prefix with module's name joined with separator. We build & deploy aux-ui-deployer for every delta-deploy call,
         * to update the launchpad, which is deployed under aux-ui-deployer module.
         * For ex: If modulesToBuild is [db-deployer, srv] and separator is ',' returned value will be
         * 'ArtifactManagementTestExample-db-deployer,ArtifactManagementTestExample-srv,ArtifactManagementTestExample-aux-ui-deployer'
         */
        const moduleNames = [];
        if (!modulesToBuild.includes('aux-ui-deployer') && modulesToBuild.includes('launchpad')) {
            modulesToBuild.push('aux-ui-deployer');
        }
        modulesToBuild = modulesToBuild.filter((module) => {
            return module !== 'launchpad' ? true : false;
        });
        for (const module of modulesToBuild) {
            moduleNames.push(this.nameFactory.getPrefix() + module);
        }
        return moduleNames.join(separator);
    }
    async readStatusTracker() {
        let modules;
        try {
            modules = await this.fs.readJson('.status_tracker');
        }
        catch (error) {
            artifact_management_base_1.getLogger().error(error);
        }
        const modulesToBuild = [];
        for (const [module, flag] of Object.entries(modules)) {
            if (flag) {
                modulesToBuild.push(module);
            }
        }
        return modulesToBuild;
    }
    async generateManifest(isDeltaBuild = false) {
        this.projectManifestGenerator = PluginFactory_1.default.getProjectGeneratorFor(this.project.type);
        const mta = await this.projectManifestGenerator.getProjectManifest(this.projectGeneratorContext);
        const builder = new MtaBuilder_1.default(this.fs, mta);
        this.moduleGenerators = this.getModuleGenerators();
        await this.getResourcesProvidedByGenerators();
        await this.generateMtaModules(builder, isDeltaBuild);
        await this.generateOverviewApplication();
        this.addResources(builder);
        const mtaObject = await builder.generate();
        if (await this.isApplicationSummaryFilePresent() && isDeltaBuild) {
            const buildParameters = mta['build-parameters'];
            const beforeAllPathAndCommands = [];
            for (const content of buildParameters['before-all']) {
                beforeAllPathAndCommands.push({
                    path: '',
                    commands: content.commands,
                });
            }
            this.moduleCommandMap.set('before-all', beforeAllPathAndCommands);
        }
        const yamlString = js_yaml_1.default.dump(mtaObject, { skipInvalid: true });
        const mtaMerger = new MtaMerger_1.default(this.fs);
        await mtaMerger.merge(yamlString);
    }
    addResources(builder) {
        for (const service of this.requiredServices) {
            const config = _.omit(service.config, 'destination');
            const requires = service.requires;
            const resource = {
                type: service.type || artifact_management_base_1.ServiceType.CF_MANAGED_SERVICE,
                name: this.nameFactory.serviceResourceName(service.name),
                requires: _.isEmpty(requires) ? undefined : requires,
                parameters: {
                    service: service.service,
                    'service-plan': service.plan,
                    'service-name': service.name,
                    path: service.path,
                    config: _.isEmpty(config) ? undefined : config,
                },
            };
            builder.addResource(resource);
        }
    }
    async getResourcesProvidedByGenerators() {
        for (let idx = 0; idx < this.moduleGenerators.length; idx++) {
            const moduleGeneratorContext = _.get(this.moduleContext, idx, this.projectGeneratorContext);
            this.resources.push(...await this.moduleGenerators[idx].provideResources(moduleGeneratorContext));
        }
        this.resources.push(...this.projectManifestGenerator.provideResources(this.projectGeneratorContext));
    }
    async generateMtaModules(builder, isDeltaBuild) {
        const builtModules = [];
        const isApplicationSummaryFilePresent = await this.isApplicationSummaryFilePresent();
        for (let idx = 0; idx < this.moduleGenerators.length; idx++) {
            const moduleGeneratorContext = _.get(this.moduleContext, idx, this.projectGeneratorContext);
            moduleGeneratorContext.builtModules = builtModules;
            moduleGeneratorContext.services = this.resources;
            const module = await this.moduleGenerators[idx].getModuleManifest(moduleGeneratorContext, this.useHeadlessGenerator);
            if (isApplicationSummaryFilePresent && isDeltaBuild && module && module['build-parameters'] && module['build-parameters'].commands) {
                switch (this.moduleGenerators[idx].constructor.name) {
                    case UI5ModuleGenerator_1.default.name:
                    case artifact_management_mdkplugin_1.MdkModuleGenerator.name:
                        let uiCommands = this.moduleCommandMap.get('aux-ui-deployer');
                        if (!uiCommands) {
                            uiCommands = [];
                        }
                        uiCommands.push({
                            path: module.path,
                            commands: module['build-parameters'].commands,
                        });
                        this.moduleCommandMap.set('aux-ui-deployer', uiCommands);
                        break;
                    /**
                    * Launchpad is deployed with aux-ui-deployer module, so PreBuild commands associated with launchpad would be executed whenever
                    * there is changes in db(non-csv file related changes), srv, mdk or ui modules.
                    */
                    case CapLaunchpadGenerator_1.default.name:
                        let launchPadCommands = this.moduleCommandMap.get('launchpad');
                        if (!launchPadCommands) {
                            launchPadCommands = [];
                        }
                        launchPadCommands.push({
                            path: module.path,
                            commands: module['build-parameters'].commands,
                        });
                        this.moduleCommandMap.set('launchpad', launchPadCommands);
                        break;
                    default:
                        break;
                }
            }
            const buildCommands = await this.moduleGenerators[idx].beforeBuildCommands(moduleGeneratorContext);
            builder.addBeforeBuildCommand(...buildCommands);
            if (module !== null) {
                const requires = this.resolveRequires(this.moduleGenerators[idx].requires(moduleGeneratorContext), idx);
                if (requires.length > 0) {
                    module.requires = requires;
                }
                builtModules.push(_.cloneDeep(module));
                builder.addModule(module);
                if (module.type === 'html5' && !this.useHeadlessGenerator) {
                    this.postProcessUI5Module(this.moduleGenerators[idx], moduleGeneratorContext);
                }
            }
        }
    }
    async postProcessUI5Module(moduleGenerator, context) {
        if (moduleGenerator.getXSAppJson) {
            const xsAppJson = moduleGenerator.getXSAppJson(context);
            await context.fs().writeJSON('webapp/xs-app.json', xsAppJson);
        }
    }
    resolveRequires(mtaModuleRequires, idx) {
        var _a;
        const requires = [];
        for (const moduleRequire of mtaModuleRequires) {
            const service = this.findService(moduleRequire);
            if (service === undefined && moduleRequire.name === undefined) {
                //if requires dependency specifies a name attribute, then use it as is. Dont interpret it as a service.
                if (moduleRequire.optional) {
                    continue;
                }
                throw new Error(`Module ${(_a = this.moduleContext[idx].module) === null || _a === void 0 ? void 0 : _a.name} - required service ${moduleRequire.serviceName} - plan ${moduleRequire.servicePlan} not provided by any module`);
            }
            if (service.type !== artifact_management_base_1.ServiceType.CAP_SERVICE) {
                //exclude cap service. This is added as a resource for destination creation alone.
                this.requiredServices.add(service);
            }
            const providedName = _.get(service, 'config.providesByName');
            const require = {
                name: service ? providedName ? providedName : this.nameFactory.serviceResourceName(service.name)
                    : moduleRequire.name,
            };
            if (moduleRequire.parameters) {
                require.parameters = moduleRequire.parameters;
            }
            requires.push(require);
        }
        return requires;
    }
    findService(moduleRequire) {
        return this.resources.find((service) => {
            if (service.service === moduleRequire.serviceName) {
                if (!moduleRequire.servicePlan || moduleRequire.servicePlan === service.plan) {
                    return service;
                }
            }
        });
    }
    getModuleGenerators() {
        const moduleManifestGenerators = this.project.modules.map(module => {
            const moduleContext = new artifact_management_base_1.ModuleGeneratorContext(this.project, this.fs.navigate(module.path), this.nameFactory, module);
            this.moduleContext.push(moduleContext);
            return PluginFactory_1.default.getModuleManifestGeneratorFor(module.type);
        });
        if (!moduleManifestGenerators.some((moduleManifestGenerator) => moduleManifestGenerator instanceof XsSecurityModuleManifestGenerator_1.default)) {
            this.moduleContext.push(new artifact_management_base_1.ModuleGeneratorContext(this.project, this.fs, this.nameFactory));
            moduleManifestGenerators.push(PluginFactory_1.default.getModuleManifestGeneratorFor(artifact_management_base_1.ModuleType.XsSecurity));
        }
        return moduleManifestGenerators.concat(this.projectManifestGenerator.getModuleGenerators(this.projectGeneratorContext));
    }
    mtarFileName() {
        return `${this.project.name}.mtar`;
    }
    async buildMtar() {
        console.log('Building mtar file...');
        const cmd = /^win/.test(process.platform) ? 'mbt.cmd' : 'mbt';
        await artifact_management_base_1.Util.exec({ cwd: this.fs.rootPath }, cmd, 'build', `--mtar=${this.mtarFileName()}`);
    }
    async buildMtad(moduleNamesToBuild) {
        const cmd = /^win/.test(process.platform) ? 'mbt.cmd' : 'mbt';
        const buildCommand = `${cmd} module-build -m ${moduleNamesToBuild} -g -p=cf`;
        await artifact_management_base_1.Util.execute(buildCommand, this.fs.rootPath);
    }
    async deploy() {
        console.log('-> Deploying mtar file...>');
        await artifact_management_base_1.Util.exec({ cwd: this.fs.rootPath }, 'cf', 'deploy', `mta_archives/${this.mtarFileName()}`, '-f');
    }
    async deployV2() {
        const isApplicationSummaryFilePresent = await this.isApplicationSummaryFilePresent();
        const modulesToDeploy = await this.readStatusTracker();
        if (modulesToDeploy.length > 0) {
            const moduleNamesToDeploy = this.generateModuleNamesToDeploy(modulesToDeploy, ' -m ');
            artifact_management_base_1.getLogger().info(`cf deploy -m ${moduleNamesToDeploy}`);
            if (isApplicationSummaryFilePresent) {
                console.log('-> Generating and Deploying mtar file...>');
            }
            let operationId = undefined;
            setTimeout(async () => {
                const oprtnId = await artifact_management_base_1.Util.execute(`cf mta-ops --mta ${this.project.name} --last 1 | sed '1,3d' | head -1 | awk '{print $1}'`, this.fs.rootPath);
                if (oprtnId && oprtnId.stdout) {
                    operationId = oprtnId.stdout.trim();
                }
            }, 30000);
            if (!isApplicationSummaryFilePresent) {
                await this.deploy();
            }
            else {
                await artifact_management_base_1.Util.execute(`cf deploy -m ${moduleNamesToDeploy} -f`, this.fs.rootPath);
            }
            const deployStatus = await artifact_management_base_1.Util.execute(`cf mta-ops --mta ${this.project.name} --last 1 | sed '1,3d' | head -1`, this.fs.rootPath);
            if (deployStatus && deployStatus.stdout) {
                const opId = deployStatus.stdout.includes(operationId);
                const status = deployStatus.stdout.match(/FINISHED|ERROR|RUNNING|ABORTED/);
                if (opId && status[0] === 'FINISHED') {
                    const statusTrackerContent = {
                        'db-deployer': false,
                        'srv': false,
                        'aux-ui-deployer': false,
                        'launchpad': false,
                    };
                    await this.fs.writeJSON('.status_tracker', statusTrackerContent);
                }
            }
        }
    }
    async updateDeployedTime() {
        console.log('-> Updating deployed time to User Provided Service...>');
        await artifact_management_base_1.Util.exec({ cwd: this.fs.rootPath }, 'cf', 'update-user-provided-service', `${this.project.name}-metadata`, '-t', `DeployedUTCTime: ${new Date().toISOString()}`);
    }
    async getDeployedTime() {
        console.log('-> Fetching deployed time from User Provided Service...>');
        const output = await artifact_management_base_1.Util.exec({ stdio: 'pipe' }, 'cf', 'service', `${this.project.name}-metadata`);
        const result = output.stdout.replace(/[\n\r]/g, '');
        const refString = 'DeployedUTCTime:';
        const pos = result.indexOf(refString);
        if (pos === -1) {
            throw new Error('Error in Application : redeploy app again');
        }
        const start = pos + refString.length + 1;
        const deployedTime = result.substring(start, result.indexOf('Z', start) + 1);
        return deployedTime;
    }
    async getProjectOverviewURL() {
        artifact_management_base_1.getLogger().info('getting project overview URL...');
        const overviewAppURL = await this.generateURLFromHtml5RepoService();
        if (overviewAppURL) {
            return overviewAppURL;
        }
        return await this.generateURLFromMetadataService();
    }
    async getApplicationLogURL() {
        artifact_management_base_1.getLogger().info('getting application log URL...');
        let apiCommandResponse;
        try {
            apiCommandResponse = await artifact_management_base_1.Util.exec({ stdio: 'pipe' }, 'cf', 'api');
            if (apiCommandResponse.stdout) {
                const found = apiCommandResponse.stdout.match(/https:\/\/(.*)[\n\r]/);
                if (found) {
                    const logDomain = found[1].replace('api', 'logs');
                    return `https://${logDomain}/app/dashboards#/view/Overview?_g=(filters:!((query:(match_phrase:(component_name:${this.project.prefix}-srv)))))`;
                }
            }
        }
        catch (error) {
            artifact_management_base_1.getLogger().error('Cannot find api endpoint \nError details: ' + error.message);
        }
        return '';
    }
    async getOverviewApplicationId() {
        try {
            const overviewAppFs = this.fs.navigate('build/launchpad');
            const manifest = new artifact_management_base_1.UIManifest(overviewAppFs, 'webapp/manifest.json');
            await manifest.load();
            const deploymentId = `${manifest.data['sap.app'].id.replace(/[-.]/g, '')}-${manifest.data['sap.app'].applicationVersion.version}`;
            if (deploymentId === '' || deploymentId === undefined || deploymentId === '-') {
                throw new Error('deployment ID value is empty or undefined');
            }
            let cloudService = this.projectGeneratorContext.project.cloudService;
            if (cloudService === '' || cloudService === undefined) {
                throw new Error('cloudService value is empty or undefined');
            }
            cloudService = cloudService.replace(/\./g, '');
            return `${cloudService}.${deploymentId}`;
        }
        catch (error) {
            artifact_management_base_1.getLogger().error('Error occured while fetching project overview application id ', error.message);
            throw new Error('build and deploy before fetching Launch URL \n error details: ' + error.message);
        }
    }
    async generateOverviewApplication() {
        const project = this.projectGeneratorContext.project;
        artifact_management_base_1.getLogger().info('Building overview application...');
        // Make overview app folder in build/
        const overviewAppPath = 'build/launchpad';
        await this.fs.mkdir(overviewAppPath, { recursive: true });
        // copy overview ui5 app template to launchpad folder
        const overviewAppTemplatePath = path_1.join(__dirname, '/templates/launchpad-ui5-app-template');
        artifact_management_base_1.getLogger().info(`Copying from :: ${overviewAppTemplatePath}/ to ${this.fs.path(overviewAppPath)}`);
        await artifact_management_base_1.Util.exec({ cwd: this.fs.rootPath }, 'cp', '-aR', `${overviewAppTemplatePath}/.`, `${this.fs.path(overviewAppPath)}`);
        this.projectGeneratorContext.services = this.resources;
        const overviewPage = new OverviewPageGenerator_1.default(this);
        await overviewPage.build(this.projectGeneratorContext, true);
        // Create overview app project with correct name and description
        const overviewAppFs = this.fs.navigate(overviewAppPath);
        const manifestJson = await overviewAppFs.renderTemplate('webapp/manifest.json', {
            appName: project.name,
        });
        overviewAppFs.writeTextFile('webapp/manifest.json', manifestJson);
        await artifact_management_base_1.Util.exec({ cwd: this.fs.rootPath }, 'rm', '-rf', `${this.fs.path(overviewAppPath)}/webapp/assets`);
        // move overview page index.html and assets to launchpad/webapp/
        await artifact_management_base_1.Util.exec({ cwd: this.fs.rootPath }, 'mv', `${this.fs.rootPath}/app/assets`, `${this.fs.path(overviewAppPath)}/webapp/`);
        await artifact_management_base_1.Util.exec({ cwd: this.fs.rootPath }, 'mv', `${this.fs.rootPath}/app/index.html`, `${this.fs.path(overviewAppPath)}/webapp/`);
        // move launchpadPage.html to launchpad/webapp/index.html
        await artifact_management_base_1.Util.exec({ cwd: this.fs.rootPath }, 'mv', `${this.fs.rootPath}/app/launchpadPage.html`, `${this.fs.path(overviewAppPath)}/webapp/`);
    }
    async generateURLFromMetadataService() {
        const applicationId = await this.getOverviewApplicationId();
        let metadataServiceResponse;
        try {
            metadataServiceResponse = await artifact_management_base_1.Util.exec({ stdio: 'pipe' }, 'cf', 'service', `${this.project.name}-metadata`, '--guid');
            if (!metadataServiceResponse.stdout) {
                throw new Error('Not able to get service guid value');
            }
        }
        catch (error) {
            throw new Error('Error in Application : redeploy app again \nError details: ' + error.message);
        }
        const guid = metadataServiceResponse.stdout.replace(/[\n\r]/g, '');
        const metadataServiceConfigResponse = await artifact_management_base_1.Util.exec({ shell: true, stdio: 'pipe' }, 'cf ', 'curl', `${'"/v3/service_instances/' + guid + '/credentials"'}`);
        if (!metadataServiceConfigResponse.stdout) {
            throw new Error('Error in response for service instance');
        }
        const result = metadataServiceConfigResponse.stdout.replace(/[\n\r]/g, '');
        const serviceMetadata = JSON.parse(result);
        if (serviceMetadata.errors && serviceMetadata.errors.length > 0) {
            if (serviceMetadata.errors[0].code === 10010) {
                throw new Error('Application not yet deployed');
            }
            throw new Error('Error in service instance: ' + metadataServiceConfigResponse.stdout);
        }
        if (!serviceMetadata['default-domain']) {
            throw new Error('default-domain value is undefined');
        }
        const serviceKeyResponse = await artifact_management_base_1.Util.exec({ shell: true, stdio: 'pipe' }, 'cf ', 'service-key', `${this.nameFactory.getPrefix() + 'uaa' + ' ' + this.nameFactory.getPrefix() + 'uaa-key'}`);
        if (!serviceKeyResponse.stdout) {
            throw new Error('Error in response for service key');
        }
        let serviceKey = serviceKeyResponse.stdout.replace(/[\n\r]/g, '');
        serviceKey = serviceKey.substring(serviceKey.indexOf('{'));
        const serviceKeyMetadata = JSON.parse(serviceKey);
        const subdomain = serviceKeyMetadata.identityzone || (serviceKeyMetadata.credentials && serviceKeyMetadata.credentials.identityzone);
        if (!subdomain) {
            throw new Error('Cannot find subdomain');
        }
        const overviewAppURL = 'https://' + subdomain + '.launchpad.' + serviceMetadata['default-domain'] + '/' + applicationId;
        return overviewAppURL;
    }
    async generateURLFromHtml5RepoService() {
        const applicationId = await this.getOverviewApplicationId();
        let serviceKeyResponse;
        let url = undefined;
        try {
            serviceKeyResponse = await artifact_management_base_1.Util.exec({ shell: true, stdio: 'pipe' }, 'cf', 'service-key', `${this.project.name}-html5-apps-repo-host ${this.project.name}-html5-apps-repo-host-key`);
            if (!serviceKeyResponse) {
                artifact_management_base_1.getLogger().debug('Not able to get response from html5-apps-repo-host service');
                return url;
            }
        }
        catch (error) {
            artifact_management_base_1.getLogger().debug('Error in Application: redeploy app again \nError details: ' + error.message);
            return url;
        }
        let result = serviceKeyResponse.stdout.replace(/[\n\r]/g, '');
        result = result.substring(result.indexOf('{'));
        const serviceKeyMetadata = JSON.parse(result);
        if (!serviceKeyMetadata['content_endpoint'] || !serviceKeyMetadata['sap.cloud.service']) {
            artifact_management_base_1.getLogger().debug('content_endpoint or sap.cloud.service is undefined in html5-apps-repo-host service');
            return url;
        }
        if (!serviceKeyMetadata.uaa) {
            artifact_management_base_1.getLogger().debug('uaa value is undefined in html5-apps-repo-host service');
            return url;
        }
        const subdomain = serviceKeyMetadata.uaa.identityzone || (serviceKeyMetadata.credentials && serviceKeyMetadata.credentials.identityzone);
        if (!subdomain) {
            artifact_management_base_1.getLogger().debug('identityzone value is undefined in html5-apps-repo-host service');
            return url;
        }
        url = serviceKeyMetadata['content_endpoint'].replace(serviceKeyMetadata['sap.cloud.service'], subdomain + '.launchpad') + '/' + applicationId;
        return url;
    }
}
exports.default = CFProjectBuilder;
CFProjectBuilder.type = 'sap.project.plugin.type.mta-project-generator';
//# sourceMappingURL=CFProjectBuilder.js.map
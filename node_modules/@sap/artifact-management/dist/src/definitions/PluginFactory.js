"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const artifact_management_base_1 = require("@sap/artifact-management-base");
const PluginDefintionProvider_1 = __importStar(require("./PluginDefintionProvider"));
/**
 * Central entrypoint for project and module specific implementations ("plugins").
 *
 * @todo: Later this needs to be able to be really plugable,
 *        meaning it should be possible to add plugins without changing this implementation.
 */
class PluginFactory {
    constructor() {
        this.plugins = {
            loaded: false,
            definition: new Map(),
        };
        this.projectReaders = {
            loaded: false,
            itemMap: new Map(),
            sortedReaders: [],
            allReadersSorted: [],
            projectWrappers: [],
        };
        this.moduleReaders = {
            loaded: false,
            itemMap: new Map(),
            sortedReaders: [],
        };
        this.itemReaders = {
            loaded: false,
            itemMap: new Map(),
        };
        this.projectManifestGenerators = {
            loaded: false,
            itemMap: new Map(),
        };
        this.moduleManifestGenerators = {
            loaded: false,
            itemMap: new Map(),
        };
        this.projectRunners = {
            loaded: false,
            itemMap: new Map(),
        };
        this.moduleRunners = {
            loaded: false,
            itemMap: new Map(),
        };
        this.moduleBuilders = {
            loaded: false,
            itemMap: new Map(),
        };
    }
    getPluginsDefinition() {
        this.loadPlugins();
        return this.plugins.definition;
    }
    getProjectReaders(readModuleAsProject) {
        this.loadProjectReaders();
        if (readModuleAsProject) {
            if (this.projectReaders.allReadersSorted.length > 0) {
                return this.projectReaders.allReadersSorted;
            }
            //should additionally even cache getProjectWrappers
            const projectWrappers = this.getProjectWrappers();
            const allReaders = this.projectReaders.sortedReaders.concat(projectWrappers);
            this.projectReaders.allReadersSorted = this.sortProjectReaders(allReaders);
            return [...this.projectReaders.allReadersSorted];
        }
        return [...this.projectReaders.sortedReaders];
    }
    getProjectWrappers() {
        if (this.projectReaders.projectWrappers.length > 0) {
            return this.projectReaders.projectWrappers;
        }
        const moduleReaders = this.getModuleReaders();
        for (const moduleReader of moduleReaders) {
            if (moduleReader.getType() !== artifact_management_base_1.ModuleType.CAP) {
                this.projectReaders.projectWrappers.push(new artifact_management_base_1.ProjectWrapper(moduleReader));
            }
        }
        return this.projectReaders.projectWrappers;
    }
    getProjectReaderFor(projectType, readModuleAsProject) {
        this.loadProjectReaders();
        const projectDataType = projectType === artifact_management_base_1.ProjectType.LCAP ? artifact_management_base_1.ProjectType.CAP : projectType;
        if (this.projectReaders.itemMap.has(projectDataType)) {
            return this.projectReaders.itemMap.get(projectDataType);
        }
        if (readModuleAsProject) {
            const projectWrappers = this.getProjectWrappers();
            for (const reader of projectWrappers) {
                if (reader.getType() === projectDataType) {
                    return reader;
                }
            }
        }
        throw new Error(`Project Type ${projectDataType} definition not found.`);
    }
    getModuleReaders() {
        this.loadModuleReaders();
        return [...this.moduleReaders.sortedReaders];
    }
    getModuleReaderFor(moduleType) {
        this.loadModuleReaders();
        if (this.moduleReaders.itemMap.has(moduleType)) {
            return this.moduleReaders.itemMap.get(moduleType);
        }
        throw new Error(`Module Type ${moduleType} definition not found.`);
    }
    getItemReaderFor(itemType) {
        this.loadItemReaders();
        if (this.itemReaders.itemMap.has(itemType)) {
            return this.itemReaders.itemMap.get(itemType);
        }
        throw new Error(`Item Type ${itemType} definition not found.`);
    }
    addModuleReader(reader) {
        this.moduleReaders.itemMap.set(reader.getType(), reader);
    }
    getModuleManifestGeneratorFor(moduleType) {
        this.loadModuleManifestGenerators();
        if (this.moduleManifestGenerators.itemMap.has(moduleType)) {
            return this.moduleManifestGenerators.itemMap.get(moduleType);
        }
        throw new Error(`Module Type ${moduleType} definition not found.`);
    }
    loadModuleManifestGenerators() {
        if (!this.moduleManifestGenerators.loaded) {
            const pluginDefinitions = this.getPluginsDefinition();
            pluginDefinitions.forEach((pluginDefinition, key) => {
                if (pluginDefinition.getModuleManifestGenerators !== undefined) {
                    pluginDefinition
                        .getModuleManifestGenerators()
                        .forEach((generator) => this.moduleManifestGenerators.itemMap.set(generator.getType(), generator));
                }
            });
            this.moduleManifestGenerators.loaded = true;
        }
    }
    getProjectGenerators() {
        this.loadProjectGenerators();
        return [...this.projectManifestGenerators.itemMap.values()];
    }
    loadProjectGenerators() {
        if (!this.projectManifestGenerators.loaded) {
            const pluginDefinitions = this.getPluginsDefinition();
            pluginDefinitions.forEach((pluginDefinition, key) => {
                if (pluginDefinition.getProjectManifestGenerators !== undefined) {
                    pluginDefinition
                        .getProjectManifestGenerators()
                        .forEach((generator) => this.projectManifestGenerators.itemMap.set(generator.getType(), generator));
                }
            });
            this.projectManifestGenerators.loaded = true;
        }
    }
    getProjectGeneratorFor(projectType) {
        this.loadProjectGenerators();
        const projectDataType = projectType === artifact_management_base_1.ProjectType.LCAP ? artifact_management_base_1.ProjectType.CAP : projectType;
        if (this.projectManifestGenerators.itemMap.has(projectDataType)) {
            return this.projectManifestGenerators.itemMap.get(projectDataType);
        }
        throw new Error(`Project Type ${projectDataType} definition not found.`);
    }
    loadPlugins() {
        if (this.plugins.loaded)
            return;
        //let pluginName: keyof typeof PLUGIN;
        for (const pluginName of Object.values(PluginDefintionProvider_1.PLUGIN)) {
            const plugin = PluginDefintionProvider_1.default.getDefintion(pluginName);
            this.plugins.definition.set(pluginName, plugin);
        }
        this.plugins.loaded = true;
    }
    getProjectRunnerFor(projectType) {
        this.loadProjectRunners();
        const projectDataType = projectType === artifact_management_base_1.ProjectType.LCAP ? artifact_management_base_1.ProjectType.CAP : projectType;
        if (this.projectRunners.itemMap.has(projectDataType)) {
            return this.projectRunners.itemMap.get(projectDataType);
        }
        throw new Error(`Project Type ${projectDataType} definition not found.`);
    }
    getModuleRunnerFor(moduleType) {
        this.loadModuleRunners();
        if (this.moduleRunners.itemMap.has(moduleType)) {
            return this.moduleRunners.itemMap.get(moduleType);
        }
        throw new artifact_management_base_1.PluginNotFoundError('module', 'undefined', moduleType);
    }
    loadModuleRunners() {
        if (!this.moduleRunners.loaded) {
            const pluginDefinitions = this.getPluginsDefinition();
            pluginDefinitions.forEach((pluginDefinition, key) => {
                if (pluginDefinition.getModuleRunner !== undefined) {
                    const runner = pluginDefinition.getModuleRunner();
                    this.moduleRunners.itemMap.set(runner.getType(), runner);
                }
            });
        }
        this.moduleRunners.loaded = true;
    }
    getModuleBuilderFor(moduleType) {
        this.loadModuleBuilders();
        if (this.moduleBuilders.itemMap.has(moduleType)) {
            return this.moduleBuilders.itemMap.get(moduleType);
        }
        throw new artifact_management_base_1.PluginNotFoundError('module', 'undefined', moduleType);
    }
    loadModuleBuilders() {
        if (!this.moduleBuilders.loaded) {
            const pluginDefinitions = this.getPluginsDefinition();
            pluginDefinitions.forEach((pluginDefinition, key) => {
                if (pluginDefinition.getModuleBuilder !== undefined) {
                    const builder = pluginDefinition.getModuleBuilder();
                    this.moduleBuilders.itemMap.set(builder.getType(), builder);
                }
            });
        }
        this.moduleBuilders.loaded = true;
    }
    loadProjectRunners() {
        if (!this.projectRunners.loaded) {
            const pluginDefinitions = this.getPluginsDefinition();
            pluginDefinitions.forEach((pluginDefinition, key) => {
                if (pluginDefinition.getProjectRunner !== undefined) {
                    const runner = pluginDefinition.getProjectRunner();
                    this.projectRunners.itemMap.set(runner.getType(), runner);
                }
            });
        }
        this.projectRunners.loaded = true;
    }
    loadProjectReaders() {
        if (!this.projectReaders.loaded) {
            const pluginDefinitions = this.getPluginsDefinition();
            pluginDefinitions.forEach((pluginDefinition, key) => {
                if (pluginDefinition.getProjectReaders !== undefined) {
                    pluginDefinition.getProjectReaders()
                        .forEach((reader) => {
                        this.projectReaders.itemMap.set(reader.getType(), reader);
                        this.projectReaders.sortedReaders = this.sortProjectReaders([...this.projectReaders.itemMap.values()]);
                    });
                }
            });
        }
        this.projectReaders.loaded = true;
    }
    loadModuleReaders() {
        if (!this.moduleReaders.loaded) {
            const pluginDefinitions = this.getPluginsDefinition();
            pluginDefinitions.forEach((pluginDefinition, key) => {
                if (pluginDefinition.getModuleReaders !== undefined) {
                    pluginDefinition.getModuleReaders()
                        .forEach((reader) => {
                        this.moduleReaders.itemMap.set(reader.getType(), reader);
                        this.sortModuleReaders([...this.moduleReaders.itemMap.values()]);
                    });
                }
            });
        }
        this.moduleReaders.loaded = true;
    }
    loadItemReaders() {
        if (!this.itemReaders.loaded) {
            const moduleReaders = this.getModuleReaders();
            for (const moduleReader of moduleReaders) {
                for (const itemReader of moduleReader.itemReaders) {
                    itemReader.types.forEach((type) => {
                        this.itemReaders.itemMap.set(type, itemReader);
                    });
                }
            }
        }
        this.itemReaders.loaded = true;
    }
    sortProjectReaders(readers) {
        return readers.filter((reader) => reader.getDetectionMechanism() !== artifact_management_base_1.DetectionMechanism.IGNORE).sort((a, b) => {
            const aDetectionPriority = artifact_management_base_1.getDetectionPriority(a.getDetectionMechanism());
            const bDetectionPriority = artifact_management_base_1.getDetectionPriority(b.getDetectionMechanism());
            if (aDetectionPriority > bDetectionPriority)
                return 1;
            if (aDetectionPriority < bDetectionPriority)
                return -1;
            if (a.getType() > b.getType())
                return 1;
            if (a.getType() < b.getType())
                return -1;
            return 0;
        });
    }
    sortModuleReaders(readers) {
        this.moduleReaders.sortedReaders = readers;
        this.moduleReaders.sortedReaders = readers.filter((reader) => reader.getDetectionMechanism() !== artifact_management_base_1.DetectionMechanism.IGNORE).sort((a, b) => {
            const aDetectionPriority = artifact_management_base_1.getDetectionPriority(a.getDetectionMechanism());
            const bDetectionPriority = artifact_management_base_1.getDetectionPriority(b.getDetectionMechanism());
            if (aDetectionPriority > bDetectionPriority)
                return 1;
            if (aDetectionPriority < bDetectionPriority)
                return -1;
            if (a.getType() > b.getType())
                return 1;
            if (a.getType() < b.getType())
                return -1;
            return 0;
        });
    }
}
exports.default = new PluginFactory();
//# sourceMappingURL=PluginFactory.js.map
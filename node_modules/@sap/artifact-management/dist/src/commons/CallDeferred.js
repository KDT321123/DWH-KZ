"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class CallDeferred {
    constructor({ func, triggerDelay, maxTriggerDelay, recallDelay }) {
        this.lastCalled = 0;
        this.incomingCall = false;
        this.callLoopRunning = false;
        this.func = func;
        this.triggerDelay = triggerDelay;
        this.maxTriggerDelay = maxTriggerDelay;
        this.recallDelay = recallDelay;
    }
    now() {
        return Date.now();
    }
    static create(options) {
        const callDeferred = new CallDeferred(options);
        return () => callDeferred.call();
    }
    call(...args) {
        this.incomingCall = true;
        if (!this.callLoopRunning) {
            this.callLoopRunning = true;
            this.callLoop(...args);
        }
    }
    async sleep(time) {
        await new Promise((resolve) => setTimeout(resolve, time));
    }
    async callLoop(...args) {
        while (this.incomingCall) {
            const nowFirst = this.now();
            const minDeferUntil = Math.max(nowFirst + this.triggerDelay, this.lastCalled + this.recallDelay);
            const maxDeferUntil = Math.max(nowFirst + this.maxTriggerDelay, minDeferUntil);
            this.incomingCall = false;
            await this.sleep(minDeferUntil - nowFirst);
            while (this.incomingCall && this.now() < maxDeferUntil) {
                this.incomingCall = false;
                await this.sleep(this.triggerDelay);
            }
            try {
                await this.func(...args);
            }
            finally {
                this.lastCalled = this.now();
            }
        }
        this.callLoopRunning = false;
    }
}
exports.default = CallDeferred;
//# sourceMappingURL=CallDeferred.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const artifact_management_base_1 = require("@sap/artifact-management-base");
const path_1 = __importDefault(require("path"));
class CapModuleReader extends artifact_management_base_1.ModuleReader {
    constructor() {
        super(...arguments);
        this.matchConditions = {
            requiredFilePatterns: ['{*.cds,*.csn,external/*.cds,external/*.csn}'],
        };
        this.itemTags = [artifact_management_base_1.Tag.Item, artifact_management_base_1.Tag.CAP];
        this.itemReaders = [
            {
                matchConditions: {
                    requiredFilePatterns: ['{*.cds,*.csn,external/*.cds,external/*.csn}'],
                },
                types: [artifact_management_base_1.ItemType.ODataV4ServiceEntity, artifact_management_base_1.ItemType.CDSEntity, artifact_management_base_1.ItemType.CAPService],
                tags: this.itemTags,
                read: (options) => this.provideFromCds(options),
                detailInfo: (fs, ref, options) => this.detailInfo(fs, ref, options),
            },
            {
                matchConditions: {
                    requiredFilePatterns: ['{csv/*.csv,src/csv/*.csv,data/*.csv,external/data/*.csv}'],
                },
                types: [artifact_management_base_1.ItemType.CSVFile],
                tags: this.itemTags,
                read: (options) => this.readCSV(options),
            },
        ];
        this.tags = [artifact_management_base_1.Tag.Module, artifact_management_base_1.Tag.CAP];
    }
    getType() {
        return artifact_management_base_1.ModuleType.CAP;
    }
    getDetectionMechanism() {
        return artifact_management_base_1.DetectionMechanism.FILE_PATTERN;
    }
    async getCapModulesFolderMap(fs) {
        const capApi = new artifact_management_base_1.CapApi(fs, ['.']);
        const cds = await capApi.cds();
        return cds.env.folders;
    }
    async getMappedFolderType(folderPath, fs) {
        const folderMap = await this.getCapModulesFolderMap(fs);
        if (folderMap) {
            if (folderMap.app && folderMap.app === folderPath) {
                return artifact_management_base_1.Tag.App;
            }
            else if (folderMap.db && folderMap.db === folderPath) {
                return artifact_management_base_1.Tag.Db;
            }
            else if (folderMap.srv && folderMap.srv === folderPath) {
                return artifact_management_base_1.Tag.Srv;
            }
        }
    }
    async read({ fs }) {
        const moduleTags = Array.from(this.tags);
        const additionalTag = await this.getMappedFolderType(fs.relativeToRoot() + '/', fs);
        if (additionalTag) {
            moduleTags.push(additionalTag);
        }
        return {
            type: artifact_management_base_1.ModuleType.CAP,
            name: fs.relativeToRoot(),
            path: fs.relativeToRoot(),
            tags: moduleTags,
        };
    }
    async provideFromCds({ fs }) {
        var _a, _b, _c, _d, _e, _f, _g;
        const items = new Map();
        const serviceRefs = {};
        const capApi = new artifact_management_base_1.CapApi(fs, ['.']);
        const modelArr = await this.getExternalServicePaths(fs);
        await capApi.load();
        const itemTags = Array.from(this.itemTags);
        const additionalTag = await this.getMappedFolderType(fs.relativeToRoot() + '/', fs);
        if (additionalTag) {
            itemTags.push(additionalTag);
        }
        const noOfServices = capApi.services().length;
        artifact_management_base_1.getLogger().debug(`Number of services from CapAPI - ${noOfServices}`);
        if (noOfServices > 0) {
            for (const service of capApi.services()) {
                const location = path_1.default.sep + service.$location.file;
                //CAP API reads files and provides location relative to root. See CapApi.load() method
                artifact_management_base_1.getLogger().debug(`Service Name :${service.name} :: location : ${location} :: basepath : ${fs.basePath}`);
                const filePath = /^win/.test(process.platform) ? this.getLocationForWindows(location, fs.rootPath) : location;
                if (!fs.isContained(filePath))
                    continue;
                const path = fs.relativeToRootFromAbsolutePath(location);
                const pathParts = path.split(/\./);
                const attrPath = pathParts[0].split('\\').join('/');
                const external = modelArr.has(attrPath) ? true : false;
                const ref = this.getServiceRef(service);
                const item = {
                    type: artifact_management_base_1.ItemType.CAPService,
                    name: service.name,
                    ref,
                    path,
                    external,
                    tags: itemTags,
                };
                if (service['@PersonalDataManagerService']) {
                    item.info = {
                        isPDMService: true,
                    };
                }
                items.set(ref, item);
                serviceRefs[service.name] = ref;
            }
        }
        const noOfEntities = capApi.entities().length;
        artifact_management_base_1.getLogger().debug(`Number of entities from CapAPI - ${noOfEntities}`);
        if (noOfEntities > 0) {
            for (const entity of capApi.entities()) {
                const entityNameParts = entity.name.split(/\./);
                const entityPath = entityNameParts.slice(0, entityNameParts.length - 1).join('.');
                const serviceRef = serviceRefs[entityPath];
                const location = path_1.default.sep + entity.$location.file;
                //CAP API reads files and provides location relative to root. See CapApi.load() method
                artifact_management_base_1.getLogger().debug(`entityName :${entity.name} :: location : ${location} :: basepath : ${fs.basePath}`);
                const filePath = /^win/.test(process.platform) ? this.getLocationForWindows(location, fs.rootPath) : location;
                if (!fs.isContained(filePath))
                    continue;
                const path = fs.relativeToRootFromAbsolutePath(location).split('\\').join('/');
                const pathParts = path.split(/\./);
                const attrPath = pathParts[0].split('\\').join('/');
                const external = modelArr.has(attrPath) ? true : false;
                const entityNamePartsLast = entityNameParts[entityNameParts.length - 1];
                const entityName = external ? entity.name : entityNamePartsLast;
                if (serviceRef) {
                    const ref = `${serviceRef}/${entityNamePartsLast}`;
                    const serviceEntity = {
                        type: artifact_management_base_1.ItemType.ODataV4ServiceEntity,
                        name: entityName,
                        ref,
                        path,
                        external,
                        tags: itemTags,
                    };
                    // Add link from Service Entity to Service
                    // Service Entity --Has Dependency--> Service
                    if (entity._service && serviceRef === this.getServiceRef(entity._service)) {
                        // Set PDM service info
                        if (entity._service['@PersonalDataManagerService']) {
                            const pdmService = items.get(serviceRef);
                            if (pdmService && !((_a = pdmService.info) === null || _a === void 0 ? void 0 : _a.isPDMItem)) {
                                pdmService.info = {
                                    'isPDMItem': true,
                                    'scopeName': entity._service['@requires'],
                                };
                                items.set(serviceRef, pdmService);
                            }
                        }
                        if (!serviceEntity.links) {
                            serviceEntity.links = [];
                        }
                        serviceEntity.links.push({
                            linkType: artifact_management_base_1.LinkType.HAS_DEPENDENCY,
                            type: artifact_management_base_1.ItemType.CAPService,
                            ref: serviceRef,
                        });
                    }
                    // Add link to DB Entity
                    if (entity.query && entity.query._target &&
                        entity.query._target.elements && !entity.query._target['@cds.persistence.skip']) {
                        const dbEntity = entity.query._target;
                        // Add link from Service Entity to DB Entity
                        // Service Entity --Depends On--> Entity
                        if (!serviceEntity.links) {
                            serviceEntity.links = [];
                        }
                        serviceEntity.links.push({
                            linkType: artifact_management_base_1.LinkType.DEPENDS_ON,
                            type: artifact_management_base_1.ItemType.CDSEntity,
                            ref: dbEntity.name,
                        });
                        // Add link from Service to DB Entity
                        // Service --Transitive Depends On--> DB Entity (Service --Depends On--> Service Entity --Depends On--> DB Entity)
                        if (entity._service && serviceRef === this.getServiceRef(entity._service) && items.get(serviceRef)) {
                            const service = items.get(serviceRef);
                            if (!service.links) {
                                service.links = [];
                            }
                            service.links.push({
                                linkType: artifact_management_base_1.LinkType.TRANSITIVELY_DEPENDS_ON,
                                type: artifact_management_base_1.ItemType.CDSEntity,
                                ref: dbEntity.name,
                            });
                        }
                    }
                    items.set(ref, serviceEntity);
                }
                if (!serviceRef && entity.elements && !entity['@cds.persistence.skip']) {
                    const namespaceValue = entity.name.match(/.*(?=\.)/) ? entity.name.match(/.*(?=\.)/)[0] : entity.name;
                    const dbEntity = {
                        type: artifact_management_base_1.ItemType.CDSEntity,
                        name: entityName,
                        ref: entity.name,
                        namespace: namespaceValue,
                        path,
                        external,
                        tags: itemTags,
                    };
                    if (entity.query) {
                        // expose virtual view db entity, e.g. projection entity, and add additional tag
                        dbEntity.tags = dbEntity.tags.concat(artifact_management_base_1.Tag.ViewEntity);
                    }
                    // Set PDM item in db/
                    for (const key of Object.keys(entity)) {
                        if (key.includes('@PersonalData')) {
                            dbEntity.info = {
                                'isPDMItem': true,
                            };
                            break;
                        }
                    }
                    //Add links from db Entity to another db Entity
                    const associations = entity.associations;
                    if (associations) {
                        if (!dbEntity.links) {
                            dbEntity.links = [];
                        }
                        for (const index in associations) {
                            if (associations[index].type !== 'cds.Composition') {
                                if (associations[index].is2one && !(associations[index].on)) {
                                    (_b = dbEntity.links) === null || _b === void 0 ? void 0 : _b.push({
                                        linkType: artifact_management_base_1.LinkType.ASSOCIATES_TO_ONE,
                                        type: artifact_management_base_1.ItemType.CDSEntity,
                                        ref: associations[index].target,
                                    });
                                }
                                if (associations[index].is2one && (associations[index].on)) {
                                    (_c = dbEntity.links) === null || _c === void 0 ? void 0 : _c.push({
                                        linkType: artifact_management_base_1.LinkType.HAS_ASSOCIATION_WITH_ONE,
                                        type: artifact_management_base_1.ItemType.CDSEntity,
                                        ref: associations[index].target,
                                    });
                                }
                                if (associations[index].is2many && !(associations[index].on)) {
                                    (_d = dbEntity.links) === null || _d === void 0 ? void 0 : _d.push({
                                        linkType: artifact_management_base_1.LinkType.ASSOCIATES_TO_MANY,
                                        type: artifact_management_base_1.ItemType.CDSEntity,
                                        ref: associations[index].target,
                                    });
                                }
                                if (associations[index].is2many && (associations[index].on)) {
                                    (_e = dbEntity.links) === null || _e === void 0 ? void 0 : _e.push({
                                        linkType: artifact_management_base_1.LinkType.HAS_ASSOCIATION_WITH_MANY,
                                        type: artifact_management_base_1.ItemType.CDSEntity,
                                        ref: associations[index].target,
                                    });
                                }
                            }
                        }
                    }
                    const compositions = entity.compositions;
                    if (compositions) {
                        if (!dbEntity.links) {
                            dbEntity.links = [];
                        }
                        for (const composition in compositions) {
                            if (compositions[composition].is2one && (compositions[composition].on)) {
                                (_f = dbEntity.links) === null || _f === void 0 ? void 0 : _f.push({
                                    linkType: artifact_management_base_1.LinkType.HAS_COMPOSITION_WITH_ONE,
                                    type: artifact_management_base_1.ItemType.CDSEntity,
                                    ref: compositions[composition].target,
                                });
                            }
                            if (compositions[composition].is2many && (compositions[composition].on)) {
                                (_g = dbEntity.links) === null || _g === void 0 ? void 0 : _g.push({
                                    linkType: artifact_management_base_1.LinkType.HAS_COMPOSITION_WITH_MANY,
                                    type: artifact_management_base_1.ItemType.CDSEntity,
                                    ref: compositions[composition].target,
                                });
                            }
                        }
                    }
                    items.set(dbEntity.ref, dbEntity);
                }
            }
        }
        artifact_management_base_1.getLogger().debug(`CapAPI Items  - ${fs.basePath} : ${JSON.stringify(items, null, 2)}`);
        return Array.from(items.values());
    }
    async detailInfo(fs, ref, options) {
        let itemInfo = undefined;
        const capApi = new artifact_management_base_1.CapApi(fs, ['.']);
        let loadOptions = undefined;
        if (options && options.inherited) {
            loadOptions = {
                flavor: 'inferred',
            };
        }
        await capApi.load(loadOptions);
        const itemTags = Array.from(this.itemTags);
        const additionalTag = await this.getMappedFolderType(fs.relativeToRoot() + '/', fs);
        if (additionalTag) {
            itemTags.push(additionalTag);
        }
        for (const entity of capApi.entities()) {
            const entityNameParts = entity.name.split(/\./);
            const entityName = entityNameParts[entityNameParts.length - 1];
            const location = path_1.default.sep + entity.$location.file;
            //CAP API reads files and provides location relative to root. See CapApi.load() method
            const filePath = /^win/.test(process.platform) ? this.getLocationForWindows(location, fs.rootPath) : location;
            if (!fs.isContained(filePath))
                continue;
            const path = fs.relativeToRootFromAbsolutePath(filePath).split('\\').join('/');
            if (entity.elements && !entity['@cds.persistence.skip'] && entity.name === ref) {
                itemInfo = {
                    type: artifact_management_base_1.ItemType.CDSEntity,
                    name: entityName,
                    ref: entity.name,
                    path,
                    info: entity.elements,
                    tags: itemTags,
                };
                if (entity.query) {
                    // expose virtual view db entity, e.g. projection entity, and add additional tag
                    itemInfo.tags = itemInfo.tags.concat(artifact_management_base_1.Tag.ViewEntity);
                }
                return itemInfo;
            }
        }
        return itemInfo;
    }
    async readCSV({ fs, matchedFiles }) {
        const items = [];
        let files = [];
        const itemTags = Array.from(this.itemTags);
        const additionalTag = await this.getMappedFolderType(fs.relativeToRoot() + '/', fs);
        if (additionalTag) {
            itemTags.push(additionalTag);
        }
        for (const pattern of Object.keys(matchedFiles)) {
            files = files.concat(matchedFiles[pattern]);
        }
        for (const file of files) {
            const path = fs.relativeToRoot(file).split('\\').join('/'); //> db/data/sap.ui.riskmanagement-Mitigations.csv OR srv/external/data/API_BUSINESS_PARTNER-A_BusinessPartner.csv
            const fileName = file.match(/[^\/]+$/)[0]; //> (db => sap.ui.riskmanagement-Mitigations.csv) OR (srv => API_BUSINESS_PARTNER-A_BusinessPartner.csv)
            const fileNameTrimmed = fileName.match(/.*(?=\.csv)/)[0]; //> (db => sap.ui.riskmanagement-Mitigations) OR (srv => API_BUSINESS_PARTNER-A_BusinessPartner)
            const fileNameParts = file.includes('external/data') ? fileNameTrimmed.split(/[\-\.](?=[^\-\.]+$)/) : fileNameTrimmed.split(/-/);
            /** fileNameParts = [API_BUSINESS_PARTNER, A_BusinessPartner] on split of API_BUSINESS_PARTNER-A_BusinessPartner,
             *  fileNameParts = [Northwind.full.url, Categories] on split of Northwind.full.url.Categories,
             *  fileNameParts = [sap.ui.riskmanagement, Mitigations] on split of sap.ui.riskmanagement-Mitigations
             */
            const modelArr = await this.getExternalServicePaths(fs);
            let external = false;
            for (const model of modelArr.values()) {
                if (model.includes(fileNameParts[0])) { //> model => srv/external/API_BUSINESS_PARTNER
                    external = true;
                    break;
                }
            }
            const prefix = external ? this.getRef(fileNameParts[0]) : fileNameParts[0]; //> (db => sap.ui.riskmanagement) OR (srv => /api-business-partner)
            const separator = external ? '/' : '.';
            const linkRef = prefix + separator + fileNameParts[1]; //> (db => sap.ui.riskmanagement.Mitigations) OR (srv => /api-business-partner/A_BusinessPartner)
            if (!fileNameParts)
                continue;
            const name = fileNameParts[1];
            let type = '';
            const csvItem = {
                type: artifact_management_base_1.ItemType.CSVFile,
                name: name,
                ref: path,
                path,
                external,
                tags: itemTags,
            };
            type = external ? artifact_management_base_1.ItemType.ODataV4ServiceEntity : artifact_management_base_1.ItemType.CDSEntity;
            if (!csvItem.links) {
                csvItem.links = [];
            }
            csvItem.links.push({
                linkType: artifact_management_base_1.LinkType.DEPENDS_ON,
                type,
                ref: linkRef,
            });
            items.push(csvItem);
        }
        return items;
    }
    async getExternalServicePaths(fs) {
        const rootFS = artifact_management_base_1.FileSystemFactory.getFileSystem(fs.rootPath);
        const helper = new artifact_management_base_1.ProjectReaderHelper(rootFS);
        const packageJson = await helper.readPackageJson();
        const modelArr = new Set();
        if (packageJson.cds && packageJson.cds.requires) {
            const objs = packageJson.cds.requires;
            for (const key in objs) {
                if (objs[key].model) {
                    modelArr.add(objs[key].model);
                }
            }
        }
        return modelArr;
    }
    getRef(fileName) {
        const prefix = '/' + ( // generate one from the service's name
        /[^.]+$/.exec(fileName)[0] //> my.very.CatalogService --> CatalogService
            .replace(/Service$/, '') //> CatalogService --> Catalog
            .replace(/([a-z0-9])([A-Z])/g, (_, c, C) => c + '-' + C.toLowerCase()) //> ODataFooBarX9 --> odata-foo-bar-x9
            .replace(/_/g, '-') //> foo_bar_baz --> foo-bar-baz
            .toLowerCase() //> FOO --> foo
        );
        return prefix;
    }
    /**
     * Get the service ref from service object.
     * The method parses the service object and
     * creates a ref following the same step as done be CDS.
     * As a result, the value will match the service endpoint value generated by CDS.
    */
    getServiceRef(service) {
        let ref = undefined;
        const path = service['@path'];
        if (path) {
            ref = path.replace(/^[^/]/, (c) => '/' + c);
        }
        else {
            if (service.name !== undefined && service.name !== '') {
                ref = this.getRef(service.name);
            }
        }
        return ref;
    }
    /**
     * Since the path would be relative to the root, in case of win OS,
     * we need to find the correct root drive and we need to prefix the path with the correct root drive (C:, D: etc.)
     */
    getLocationForWindows(path, rootPath) {
        return path_1.default.join(rootPath.split(path_1.default.sep)[0], path);
    }
}
exports.default = CapModuleReader;
//# sourceMappingURL=CapModuleReader.js.map
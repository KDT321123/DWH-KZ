"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const artifact_management_base_1 = require("@sap/artifact-management-base");
const simple_git_1 = __importDefault(require("simple-git"));
const path_1 = __importDefault(require("path"));
const mtaFile = 'mta.yaml';
const autoHiddenFile = '.mta.yaml.snapshot';
const autoMemoryFile = '.mta.yaml.memory';
const autoDiffFile = '.snapshot.diff';
class MtaMerger {
    constructor(fs) {
        this.fs = fs;
        this.git = simple_git_1.default(fs.rootPath);
        this.logger = new artifact_management_base_1.ProjectAPILogger(artifact_management_base_1.getLogger().getChildLogger({ label: 'mtaMerger' }));
    }
    get Git() {
        return this.git;
    }
    async merge(content) {
        let hasConflict = false;
        if (await this.fs.fileExists(mtaFile) && await this.fs.fileExists(autoHiddenFile)) {
            if (await this.areDiffFiles(autoHiddenFile, mtaFile)) {
                await this.fs.writeTextFile(autoMemoryFile, content);
                const gitRootPath = await this.git.revparse('--show-toplevel');
                const tempFs = artifact_management_base_1.FileSystemFactory.getFileSystem(this.fs.basePath, gitRootPath);
                const relativeFolder = tempFs.relativeToRoot('.');
                await this.writeDataObject(autoHiddenFile);
                if (await this.diffAutoMtaFile(autoHiddenFile, autoMemoryFile, relativeFolder)) {
                    await this.addToIndex(mtaFile);
                    hasConflict = await this.applyDiff(autoDiffFile, mtaFile, relativeFolder);
                    if (!hasConflict) {
                        await this.removeIndex(mtaFile);
                    }
                }
                await this.fs.rm(autoMemoryFile);
            }
            else {
                await this.fs.writeTextFile(mtaFile, content);
            }
        }
        else {
            await this.fs.writeTextFile(mtaFile, content);
        }
        // Override the content of the hidden file for next diff operation
        await this.fs.writeTextFile(autoHiddenFile, content);
        // Remove the unused diff file
        if (await this.fs.fileExists(autoDiffFile)) {
            await this.fs.rm(autoDiffFile);
        }
        if (hasConflict) {
            throw new Error((`Failed to update ${mtaFile} due to conflicts. Please open ${mtaFile} and resolve the conflicts.`));
        }
    }
    async writeDataObject(file) {
        const checksum = await this.git.raw(['hash-object', '-w', file]);
        return checksum;
    }
    async areDiffFiles(file1, file2) {
        const checksum1 = await this.git.raw(['hash-object', file1]);
        const checksum2 = await this.git.raw(['hash-object', file2]);
        return checksum1 !== checksum2;
    }
    async getDiffContent(baseFile, changedFile) {
        const diffCommand = [
            'diff',
            '--no-index',
            baseFile,
            changedFile,
        ];
        let content = '';
        await this.git.raw(diffCommand, (error, result) => {
            if (!error) {
                content = result;
            }
            else {
                this.logger.error(error.message);
            }
        });
        return content;
    }
    async diffAutoMtaFile(hiddenFile, memoryFile, relativeFolder) {
        let content = await this.getDiffContent(hiddenFile, memoryFile);
        if (content) {
            const relativeMtaFilePath = path_1.default.join(relativeFolder, mtaFile);
            const regExpA = new RegExp('a/' + autoHiddenFile, 'g');
            content = content.replace(regExpA, `a/${relativeMtaFilePath}`);
            const regExpB = new RegExp('b/' + autoMemoryFile, 'g');
            content = content.replace(regExpB, `b/${relativeMtaFilePath}`);
            await this.fs.writeTextFile(autoDiffFile, content);
            return true;
        }
        else {
            return false;
        }
    }
    async addToIndex(mtaFile) {
        const addCommand = [
            'add',
            mtaFile,
        ];
        return this.git.raw(addCommand, (error, result) => {
            if (!error) {
                this.logger.trace(result);
            }
            else {
                this.logger.error(error.message);
            }
        });
    }
    async applyDiff(diffFile, mtaFile, relativeFolder) {
        let hasConflict = false;
        const relativeMtaFilePath = path_1.default.join(relativeFolder, mtaFile);
        try {
            await this.git.raw(['apply', '-3', autoDiffFile]);
        }
        catch (error) {
            if (error.message.indexOf(`Applied patch to '${relativeMtaFilePath}' with conflicts`) > -1) {
                this.logger.warn(error.message);
                hasConflict = true;
            }
            else {
                this.logger.error(error.message);
                throw error;
            }
        }
        return hasConflict;
    }
    async removeIndex(mtaFile) {
        const addCommand = [
            'reset',
            mtaFile,
        ];
        return this.git.raw(addCommand, (error, result) => {
            if (!error) {
                this.logger.trace(result);
            }
            else {
                this.logger.error(error.message);
            }
        });
    }
}
exports.default = MtaMerger;
//# sourceMappingURL=MtaMerger.js.map
/// <reference types="node" />
import { ProjectFileSystem, FileSystemWatchManager, ProjectEntityReader } from '@sap/artifact-management-base';
import { EventEmitter } from 'events';
declare type LoadResult<T> = {
    data: T | undefined;
    watchPatterns: string[];
} | undefined;
declare type LoadData<T> = () => Promise<LoadResult<T>>;
export default class ProjectEntityInstance<T> extends EventEmitter {
    protected readonly watchManager: FileSystemWatchManager;
    protected fs: ProjectFileSystem;
    private loaded;
    private children;
    readData?: () => Promise<T>;
    private data?;
    protected _type?: string;
    private observers;
    private staleData;
    tags: string[];
    constructor(watchManager: FileSystemWatchManager, fs: ProjectFileSystem);
    /**
     * Get child data of an entity
     *
     * The "load" function is called to receive the data. The resulting data will be cached.
     * As there can be multiple children, they need to be distinguished by "name" which is used as cache key.
     *
     * Call "unloadChildren()" to clear the cache. The method "load" will be called again with the next call
     * of "getChildCache()".
     *
     */
    protected getChildCached<Child>({ name, load }: {
        name: string;
        load: () => Promise<Child>;
    }): Promise<Child>;
    /**
     * Get data of an entity
     *
     * The "load" function is called to receive the data. The resulting data will be cached.
     *
     * The "onDataChanged" function is called when the data is changed compared to a previous call. It can
     * be used to invalidate depending data, e.g. children by calling "unloadChildren()".
     *
     * Call "unloadData()" to clear the cache. The method "load" will be called again with the next call
     * of "getDataCached()"
     *
     * An instance must have only one method where "getDataCached()" is called otherwise a call will
     * return the previously cached value of a different one.
     *
     */
    protected getDataCached({ load, onDataChanged }: {
        load: LoadData<T>;
        onDataChanged?: (newData: T, oldData: T) => void;
    }): Promise<T>;
    registerWatchPatterns(patterns: string[], callback?: (event: string, file: string) => void): Promise<void>;
    flagModuleDirty(path: string): Promise<void>;
    unRegisterWatchPatterns(): void;
    loadByReader(reader: ProjectEntityReader<T>): Promise<LoadResult<T>>;
    loadByReaders(readers: ProjectEntityReader<T>[]): Promise<LoadResult<T>>;
    invalidate(): Promise<void>;
    unload(): void;
    destroy(): void;
    unloadChildren(): void;
}
export {};

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAnnotationNamespaces = void 0;
const fast_xml_parser_1 = require("fast-xml-parser");
const i18n_1 = require("../i18n");
/**
 * Returns the namespaces parsed from the specified metadata and annotations.
 *
 * @param {Partial<OdataService>} service - an odata service where at least metadata and annotations properties are defined
 * @param {string} service.metadata - OData service metadata xml
 * @param {string} service.annotations - OData service annotations xml
 * @returns A reference to the namspaces array
 */
function getAnnotationNamespaces({ metadata, annotations }) {
    // Enhance service with annotations namespaces
    const schemaNamespaces = metadata ? getNamespaces(metadata) : [];
    if (annotations === null || annotations === void 0 ? void 0 : annotations.xml) {
        // Parse once
        const annotationsJson = xmlToJson(annotations.xml);
        return schemaNamespaces.map((schema) => {
            // Check if alias exists in backend annotation file, if so use it
            const annotationAlias = annotations.xml && schema.namespace ? getAliasFromAnnotation(annotationsJson, schema.namespace) : '';
            if (annotationAlias) {
                schema.alias = annotationAlias;
            }
            return schema;
        });
    }
    return schemaNamespaces;
}
exports.getAnnotationNamespaces = getAnnotationNamespaces;
/**
 * Convert specified xml string to JSON.
 *
 * @param xml - the schema to parse
 * @returns parsed object representation of passed XML
 */
function xmlToJson(xml) {
    const options = {
        attributeNamePrefix: '',
        ignoreAttributes: false,
        ignoreNameSpace: true,
        parseAttributeValue: true
    };
    try {
        const parser = new fast_xml_parser_1.XMLParser(options);
        return parser.parse(xml, true);
    }
    catch (error) {
        throw new Error(i18n_1.t('error.unparseableXML', { error }));
    }
}
/**
 * Gets all the schema namespaces and their aliases from the provided metadata.
 *
 * @param metadata - odata service metadata
 * @returns Array of namespaces and their aliases
 */
function getNamespaces(metadata) {
    var _a, _b;
    const jsonMetadata = xmlToJson(metadata);
    let schema = (_b = (_a = jsonMetadata['edmx:Edmx']) === null || _a === void 0 ? void 0 : _a['edmx:DataServices']) === null || _b === void 0 ? void 0 : _b['Schema'];
    if (!schema) {
        return [];
    }
    // Can be array or single item
    if (!Array.isArray(schema)) {
        schema = [schema];
    }
    return schema.map((item) => {
        return {
            namespace: item.Namespace,
            alias: item.Alias || ''
        };
    });
}
/**
 * Gets namespace aliases from the specified annotations xml.
 *
 * @param annotations - annotations definition as json
 * @param namespace - the namespace to search
 * @returns An alias for the specified namespace or empty string
 */
function getAliasFromAnnotation(annotations, namespace) {
    var _a, _b;
    let references = (_a = annotations['edmx:Edmx']) === null || _a === void 0 ? void 0 : _a['edmx:Reference'];
    // Can be array or single item
    if (!Array.isArray(references)) {
        references = [references];
    }
    const annoNamespace = references.find((ref) => { var _a, _b; return ((_a = ref['edmx:Include']) === null || _a === void 0 ? void 0 : _a['Namespace']) === namespace && ((_b = ref['edmx:Include']) === null || _b === void 0 ? void 0 : _b['Alias']); });
    return annoNamespace ? (_b = annoNamespace['edmx:Include']) === null || _b === void 0 ? void 0 : _b['Alias'] : '';
}
//# sourceMappingURL=annotations.js.map
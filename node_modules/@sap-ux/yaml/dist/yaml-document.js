"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.YamlDocument = void 0;
const i18n_1 = require("./i18n");
const yaml_1 = __importStar(require("yaml"));
const merge = require("lodash.merge");
/**
 * Represents a yaml document with utility functions to manipulate the document.
 *
 * @class YamlDocument
 */
class YamlDocument {
    /**
     * Creates an instance of YamlDocument.
     *
     * @param {string} serializedYaml - the serialized yaml string
     * @memberof YamlDocument
     */
    constructor(serializedYaml) {
        var _a;
        this.document = yaml_1.default.parseDocument(serializedYaml);
        if (((_a = this.document.errors) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            throw new Error(i18n_1.t('error.yamlParsing') + '\n' + this.document.errors.map((e) => e.message).join(''));
        }
    }
    /**
     * Returns a new instance of YamlDocument.
     *
     * @static
     * @param {string} serializedYaml - the serialized yaml string
     * @returns {YamlDocument} the YamlDocument instance
     * @memberof YamlDocument
     */
    static newInstance(serializedYaml) {
        return __awaiter(this, void 0, void 0, function* () {
            yield i18n_1.initI18n();
            return new YamlDocument(serializedYaml);
        });
    }
    /**
     * Returns a string representation of the yaml document.
     *
     * @returns {string} the string representation
     * @memberof YamlDocument
     */
    toString() {
        return this.document.toString({ singleQuote: true });
    }
    /**
     * Adds a comment to the yaml document.
     *
     * @param root0 - the comment object
     * @param root0.comment - the comment object's comment
     * @param root0.location - the comment object's location
     * @returns {YamlDocument} the YamlDocument instance
     * @memberof YamlDocument
     */
    addDocumentComment({ comment, location = 'beginning' }) {
        switch (location) {
            case 'beginning':
                this.document.commentBefore = comment;
                break;
            case 'end':
                this.document.comment = comment;
                break;
            default:
                break;
        }
        return this;
    }
    /**
     * Set the value at a given path.
     *
     * @param path - hierarchical path where the node will be inserted/updated
     * @param path.path - the path object's path
     * @param path.value - the path object's value
     * @param path.createIntermediateKeys - create the intermediate keys if they're missing. Error if not
     * @param path.comment - an optional comment
     * @example
     * If the document is:
     * key1:
     *   key2: value2
     *   key3:
     *     key4:
     *       - item: item1
     *       - item: item2
     *
     * To set the second item, the path will be `key1.key3.key4.1.item`
     * To set key2's value: `key1.key2`
     * To set a property at the root: 'keyX'
     * @returns {YamlDocument} the YamlDocument instance
     * @memberof YamlDocument
     */
    setIn({ path, value, createIntermediateKeys, comment }) {
        const pathArray = this.toPathArray(path);
        if (pathArray.length > 1) {
            const parentPath = pathArray.slice(0, -1);
            const parentNode = this.document.getIn(parentPath);
            if (!parentNode && !createIntermediateKeys) {
                // Not at root and we're not asked to create the intermediate keys
                throw new Error(i18n_1.t('error.pathDoesNotExist', { path: parentPath }));
            }
        }
        const newNode = this.document.createNode(value);
        if (comment) {
            newNode.commentBefore = comment;
        }
        this.document.setIn(pathArray, newNode);
        return this;
    }
    /**
     * Appends a node to a sequence in the document.
     *
     * @param path - hierarchical path where the node will be inserted/updated
     * @param {string} path.path - the path object's path
     * @param {object} path.value - the path object's value
     * @param {boolean} path.createIntermediateKeys - create the intermediate keys if they're missing. Error if not
     * @param path.nodeComment - optional comment to add to the node
     * @param path.comments - optional comments for subnodes in value being added
     * @returns {YamlDocument} the YamlDocument instance
     * @memberof YamlDocument
     */
    appendTo({ path, value, createIntermediateKeys = true, nodeComment, comments }) {
        const pathArray = this.toPathArray(path);
        let seq = this.document.getIn(pathArray);
        if (!seq) {
            if (!createIntermediateKeys) {
                throw new Error(i18n_1.t('error.seqDoesNotExist', { path }));
            }
            seq = new yaml_1.YAMLSeq();
            this.document.setIn(pathArray, seq);
        }
        else if (!yaml_1.isSeq(seq)) {
            throw new Error(i18n_1.t('error.tryingToAppendToNonSequence', { path }));
        }
        const newNode = this.document.createNode(value);
        if (nodeComment) {
            newNode.commentBefore = nodeComment;
        }
        seq.items.push(newNode);
        if (comments && comments.length > 0) {
            if (typeof value !== 'object') {
                throw new Error(i18n_1.t('error.scalarValuesDoNotHaveProperties'));
            }
            const index = seq.items.length - 1;
            for (const c of comments) {
                const propPathArray = this.toPathArray(c.path);
                const n = this.document.getIn([...pathArray, index, ...propPathArray], true);
                if (!n) {
                    throw new Error(i18n_1.t('error.propertyNotFound', { path: c.path }));
                }
                n.comment = c.comment;
            }
        }
        return this;
    }
    /**
     * Updates a node in a sequence in the document.
     *
     * @param path - hierarchical path where the node will be inserted/updated
     * @param {string} path.path - the path object's path
     * @param {object} path.matcher - key/value pair identifying the object
     * @param {object} path.value - the path object's value
     * @param path.matcher.key
     * @param path.matcher.value
     * @returns {YamlDocument} the YamlDocument instance
     * @memberof YamlDocument
     */
    updateAt({ path, matcher, value }) {
        const pathArray = this.toPathArray(path);
        const seq = this.document.getIn(pathArray);
        if (!seq) {
            throw new Error(i18n_1.t('error.seqDoesNotExist', { path }));
        }
        const node = seq.items.find((nodeInput) => nodeInput.toJSON()[matcher.key] === matcher.value);
        const newNode = this.document.createNode(merge(node.toJSON(), value));
        seq.items.splice(seq.items.indexOf(node), 1, newNode);
        return this;
    }
    /**
     * Deletes a node in a sequence in the document.
     *
     * @param path - hierarchical path where the node will be deleted
     * @param {string} path.path - the path object's path
     * @param {object} path.matcher - key/value pair identifying the object
     * @param {string} path.matcher.key - the key
     * @param {string} path.matcher.value - the value
     * @returns {YamlDocument} the YamlDocument instance
     * @memberof YamlDocument
     */
    deleteAt({ path, matcher }) {
        const pathArray = this.toPathArray(path);
        const seq = this.document.getIn(pathArray);
        if (!seq || !seq.items) {
            throw new Error(i18n_1.t('error.seqDoesNotExist', { path }));
        }
        const deletedNode = seq.items.find((node, index) => {
            if (node.toJSON()[matcher.key] === matcher.value) {
                seq.items.splice(index, 1);
                return true;
            }
            else {
                return false;
            }
        });
        if (!deletedNode) {
            throw new Error(i18n_1.t('error.propertyNotFound', { path }));
        }
        return this;
    }
    /**
     * @param root0
     * @param root0.start
     * @param root0.path
     * @returns {unknown}
     */
    getNode({ start, path }) {
        if (start) {
            if (!(yaml_1.isSeq(start) || yaml_1.isMap(start))) {
                throw new Error(i18n_1.t('error.startNodeMustBeCollection'));
            }
        }
        const pathArray = this.toPathArray(path);
        const node = start || this.document;
        const targetNode = node === null || node === void 0 ? void 0 : node.getIn(pathArray);
        if (!targetNode) {
            throw new Error(i18n_1.t('error.nodeNotFound', { path }));
        }
        else {
            return targetNode;
        }
    }
    /**
     * @param root0
     * @param root0.start
     * @param root0.path
     * @returns {unknown}
     */
    getSequence({ start, path }) {
        const a = this.getNode({ start, path });
        if (!yaml_1.isSeq(a)) {
            throw new Error(i18n_1.t('error.seqDoesNotExist', { path }));
        }
        else {
            return a;
        }
    }
    /**
     * @param root0
     * @param root0.start
     * @param root0.path
     * @returns {YAMLMap}
     */
    getMap({ start, path }) {
        const a = this.getNode({ start, path });
        if (!yaml_1.isMap(a)) {
            throw new Error(i18n_1.t('error.nodeNotAMap', { path }));
        }
        else {
            return a;
        }
    }
    /**
     * @param sequence
     * @param predicate
     * @returns {unknown}
     */
    findItem(sequence, predicate) {
        const toJson = (o) => (o !== undefined && typeof o.toJSON === 'function' && o.toJSON.call(o)) || {};
        return sequence.items.find((item) => predicate(toJson(item)));
    }
    /**
     * Converts to a path object to an array.
     *
     * @private
     * @template T
     * @param {Path<T>} path - the path object
     * @returns {string[]} - the path array
     * @memberof YamlDocument
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    toPathArray(path) {
        const result = path === null || path === void 0 ? void 0 : path.toString().split('.').filter((p) => p !== '');
        if (!result || result.length === 0) {
            throw new Error(i18n_1.t('error.pathCannotBeEmpty'));
        }
        return result;
    }
}
exports.YamlDocument = YamlDocument;
//# sourceMappingURL=yaml-document.js.map